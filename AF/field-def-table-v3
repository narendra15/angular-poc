import { Component, OnInit } from '@angular/core';
import {
  AbstractControl,
  FormArray,
  FormBuilder,
  FormGroup,
  Validators,
} from '@angular/forms';

@Component({
  selector: 'app-field-definition-grid',
  templateUrl: './field-definition-grid.component.html',
})
export class FieldDefinitionGridComponent implements OnInit {
  /** ðŸ”‘ Future toggle */
  enableExistingRows = false;

  form!: FormGroup;

  displayedColumns = [
    'tableName',
    'columnName',
    'uiFieldName',
    'formField',
    'fieldCategory',
    'fieldRequirement',
    'dependentField',
    'fieldDataType',
    'fieldMaxLength',
    'numericPrecision',
    'numericScale',
    'defaultValue',
    'editableByUser',
    'validationRuleExists',
    'derivationRuleExists',
    'allowedValues',
    'standardValues',
    'positionInTemplate',
  ];

  /* ---------- DROPDOWN OPTIONS ---------- */

  formFieldOptions = [
    { label: 'Free text', value: 'Free text' },
    { label: 'Radio button', value: 'Radio button' },
    { label: 'Drop down', value: 'Drop down' },
    { label: 'Date picker', value: 'Date picker' },
  ];

  fieldCategoryOptions = [
    { label: 'User', value: 'User' },
    { label: 'Derived', value: 'Derived' },
  ];

  fieldRequirementOptions = [
    { label: 'Mandatory', value: 'Mandatory' },
    { label: 'Conditionally mandatory', value: 'Conditionally mandatory' },
    { label: 'Optional', value: 'Optional' },
  ];

  yesNoOptions = [
    { label: 'Yes', value: 'Yes' },
    { label: 'No', value: 'No' },
  ];

  allowedValuesOptions = [
    { label: 'STANDARD_VALUES', value: 'STANDARD_VALUES' },
    { label: 'NOT_APPLICABLE', value: 'NOT_APPLICABLE' },
  ];

  /* ---------- SAMPLE API DATA ---------- */

  rowData = {
    bcl_cv: ['eff_ts', 'end_ts'],
    bcl_err_tbl: ['file_name', 'end_ts'],
  };

  metaData: any = {
    bcl_cv: {
      eff_ts: {
        field_data_type: 'character varying',
        field_maximum_length: 50,
        numeric_precision: null,
        numeric_scale: null,
      },
      end_ts: {
        field_data_type: 'bigint',
        field_maximum_length: null,
        numeric_precision: 64,
        numeric_scale: 0,
      },
    },
  };

  existingData: any = {
    bcl_cv: {
      eff_ts: {
        system_field_name: 'RPT_DATA_DATE',
        form_field: 'Date picker',
        field_category: 'User',
        field_requirement: 'Mandatory',
        dependent_field: null,
        field_default_value: null,
        field_editable: 'Yes',
        field_validation_rule_exists: 'Yes',
        field_derivation_rule_exists: 'Yes',
        field_allowed_values: 'NOT_APPLICABLE',
        field_standard_values: null,
        field_position_in_template: 1,
      },
    },
  };

  constructor(private fb: FormBuilder) {}

  ngOnInit(): void {
    this.form = this.fb.group({
      rows: this.fb.array([], this.uniqueUiFieldValidator()),
    });
    this.buildRows();
  }

  get rows(): FormArray {
    return this.form.get('rows') as FormArray;
  }

  /* ---------- BUILD GRID ---------- */

  private buildRows(): void {
    Object.entries(this.rowData).forEach(([table, columns]) => {
      columns.forEach((column) => {
        const meta = this.metaData?.[table]?.[column] ?? {};
        const existing = this.existingData?.[table]?.[column] ?? null;

        const row = this.createRow(table, column, meta, existing);
        this.rows.push(row);

        if (existing && !this.enableExistingRows) {
          row.disable({ emitEvent: false });
        }
      });
    });
  }

  private createRow(
    table: string,
    column: string,
    meta: any,
    existing: any
  ): FormGroup {
    const fg = this.fb.group({
      tableName: [{ value: table, disabled: true }],
      columnName: [{ value: column, disabled: true }],

      uiFieldName: [
        existing?.system_field_name ?? null,
        [
          Validators.required,
          Validators.minLength(5),
          Validators.maxLength(50),
          Validators.pattern(/^[A-Za-z ]+$/),
        ],
      ],

      formField: [existing?.form_field ?? null, Validators.required],
      fieldCategory: [existing?.field_category ?? null, Validators.required],
      fieldRequirement: [existing?.field_requirement ?? null],
      dependentField: [existing?.dependent_field ?? null],

      fieldDataType: [{ value: meta.field_data_type ?? null, disabled: true }],
      fieldMaxLength: [{ value: meta.field_maximum_length ?? null, disabled: true }],
      numericPrecision: [{ value: meta.numeric_precision ?? null, disabled: true }],
      numericScale: [{ value: meta.numeric_scale ?? null, disabled: true }],

      defaultValue: [existing?.field_default_value ?? null],
      editableByUser: [existing?.field_editable ?? null],
      validationRuleExists: [
        existing?.field_validation_rule_exists ?? null,
        Validators.required,
      ],
      derivationRuleExists: [
        existing?.field_derivation_rule_exists ?? null,
        Validators.required,
      ],
      allowedValues: [existing?.field_allowed_values ?? null],
      standardValues: [existing?.field_standard_values ?? null],
      positionInTemplate: [
        existing?.field_position_in_template ?? null,
        Validators.pattern(/^[0-9]+$/),
      ],
    });

    this.attachRules(fg);
    return fg;
  }

  /* ---------- RULE ENGINE ---------- */

  private attachRules(row: FormGroup): void {
    row.get('fieldCategory')?.valueChanges.subscribe((val) => {
      const req = row.get('fieldRequirement');
      if (val === 'Derived') {
        req?.disable();
        req?.setValue(null);
      } else {
        req?.enable();
      }
    });

    row.get('defaultValue')?.valueChanges.subscribe((val) => {
      const allowed = row.get('allowedValues');
      if (val !== null && val !== '') {
        allowed?.enable();
      } else {
        allowed?.disable();
        allowed?.setValue(null);
      }
    });

    row.get('allowedValues')?.valueChanges.subscribe((val) => {
      const std = row.get('standardValues');
      if (val === 'STANDARD_VALUES') {
        std?.enable();
        std?.setValidators(this.standardValuesValidator());
      } else {
        std?.disable();
        std?.setValue(null);
      }
      std?.updateValueAndValidity();
    });
  }

  /* ---------- HELPERS ---------- */

  getDependentOptions(index: number) {
    return this.rows.controls
      .map((ctrl, i) => ({
        i,
        name: ctrl.get('uiFieldName')?.value,
      }))
      .filter((x) => x.i !== index && !!x.name)
      .map((x) => ({ label: x.name, value: x.name }));
  }

  isDependentDisabled(index: number): boolean {
    const row = this.rows.at(index) as FormGroup;
    return (
      row.get('fieldRequirement')?.value !== 'Conditionally mandatory' ||
      this.rows.length < 2
    );
  }

  /* ---------- VALIDATORS ---------- */

  private uniqueUiFieldValidator() {
    return (control: AbstractControl) => {
      const names = (control as FormArray).controls
        .map((c) => c.get('uiFieldName')?.value?.toLowerCase())
        .filter(Boolean);
      return new Set(names).size === names.length
        ? null
        : { duplicateUiFieldName: true };
    };
  }

  private standardValuesValidator() {
    return (control: AbstractControl) => {
      if (!control.value) return null;
      const values = control.value.split(',');
      if (values.length > 10) return { maxStandardValues: true };
      const regex = /^(\d+|"[A-Za-z0-9 ]+")$/;
      return values.every((v: string) => regex.test(v.trim()))
        ? null
        : { invalidStandardValue: true };
    };
  }

  /* ---------- SAVE ---------- */

  save(): void {
    if (this.form.invalid) {
      this.form.markAllAsTouched();
      return;
    }
    console.log('FINAL PAYLOAD', this.rows.getRawValue());
  }
}



////////////////////


<form [formGroup]="form">
  <table mat-table [dataSource]="rows.controls" formArrayName="rows">

    <ng-container *ngFor="let col of displayedColumns" [matColumnDef]="col">
      <th mat-header-cell *matHeaderCellDef>{{ col }}</th>
      <td mat-cell *matCellDef="let row; let i = index" [formGroupName]="i">

        <!-- TEXT / READONLY -->
        <ng-container *ngIf="['tableName','columnName','fieldDataType','fieldMaxLength','numericPrecision','numericScale'].includes(col)">
          {{ row.get(col)?.value }}
        </ng-container>

        <!-- INPUT -->
        <input
          *ngIf="['uiFieldName','defaultValue','standardValues','positionInTemplate'].includes(col)"
          matInput
          [formControlName]="col"
        />

        <!-- BMO SELECTS -->
        <bmo-select
          *ngIf="col === 'formField'"
          [options]="formFieldOptions"
          formControlName="formField"
        ></bmo-select>

        <bmo-select
          *ngIf="col === 'fieldCategory'"
          [options]="fieldCategoryOptions"
          formControlName="fieldCategory"
        ></bmo-select>

        <bmo-select
          *ngIf="col === 'fieldRequirement'"
          [options]="fieldRequirementOptions"
          formControlName="fieldRequirement"
        ></bmo-select>

        <bmo-select
          *ngIf="col === 'dependentField'"
          [options]="getDependentOptions(i)"
          [disabled]="isDependentDisabled(i)"
          formControlName="dependentField"
        ></bmo-select>

        <bmo-select
          *ngIf="['editableByUser','validationRuleExists','derivationRuleExists'].includes(col)"
          [options]="yesNoOptions"
          [formControlName]="col"
        ></bmo-select>

        <bmo-select
          *ngIf="col === 'allowedValues'"
          [options]="allowedValuesOptions"
          formControlName="allowedValues"
        ></bmo-select>

      </td>
    </ng-container>

    <tr mat-header-row *matHeaderRowDef="displayedColumns"></tr>
    <tr mat-row *matRowDef="let row; columns: displayedColumns"></tr>
  </table>

  <br />
  <button mat-raised-button color="primary" (click)="save()">Save</button>
</form>




//////------/////////--------/////////-------

Helpers


hasError(rowIndex: number, controlName: string, error: string): boolean {
  const ctrl = (this.rows.at(rowIndex) as FormGroup).get(controlName);
  return !!(ctrl && ctrl.touched && ctrl.hasError(error));
}

showError(rowIndex: number, controlName: string): boolean {
  const ctrl = (this.rows.at(rowIndex) as FormGroup).get(controlName);
  return !!(ctrl && ctrl.touched && ctrl.invalid);
}

getUiFieldNameError(rowIndex: number): string {
  const ctrl = (this.rows.at(rowIndex) as FormGroup).get('uiFieldName');
  if (!ctrl || !ctrl.touched) return '';

  if (ctrl.hasError('required')) return 'UI Field Name is required';
  if (ctrl.hasError('minlength')) return 'Minimum 5 characters required';
  if (ctrl.hasError('maxlength')) return 'Maximum 50 characters allowed';
  if (ctrl.hasError('pattern'))
    return 'Only alphabets and spaces are allowed';

  if (this.form.hasError('duplicateUiFieldName'))
    return 'UI Field Name must be unique';

  return '';
}

getStandardValuesError(rowIndex: number): string {
  const ctrl = (this.rows.at(rowIndex) as FormGroup).get('standardValues');
  if (!ctrl || !ctrl.touched) return '';

  if (ctrl.hasError('maxStandardValues'))
    return 'Maximum 10 comma-separated values allowed';

  if (ctrl.hasError('invalidStandardValue'))
    return 'Values must be numeric or quoted alphanumeric ("ABC")';

  return '';
}


// -- UI Field Name

<input
  matInput
  formControlName="uiFieldName"
/>

<mat-error *ngIf="showError(i, 'uiFieldName')">
  {{ getUiFieldNameError(i) }}
</mat-error>


// -- Default Value

<input
  matInput
  formControlName="defaultValue"
/>

<mat-error *ngIf="hasError(i, 'defaultValue', 'pattern')">
  Invalid value for selected data type
</mat-error>


// -- Standard Values

<input
  matInput
  formControlName="standardValues"
/>

<mat-error *ngIf="showError(i, 'standardValues')">
  {{ getStandardValuesError(i) }}
</mat-error>


// -- Form Field, fieldCategory, validationRuleExists, derivationRuleExists

<bmo-select
  [options]="formFieldOptions"
  formControlName="formField"
></bmo-select>

<mat-error *ngIf="hasError(i, 'formField', 'required')">
  Form Field is required
</mat-error>


// -- Sticky header ---- //
<tr
  mat-header-row
  *matHeaderRowDef="displayedColumns; sticky: true"
></tr>

<ng-container matColumnDef="tableName" sticky>
<ng-container matColumnDef="columnName" sticky>


///////////

table {
  width: 100%;
}

th.mat-header-cell {
  background: #f5f5f5;
  z-index: 10;
}

td.mat-cell,
th.mat-header-cell {
  padding: 8px 12px;
  vertical-align: top;
}

mat-error {
  font-size: 11px;
  line-height: 1.2;
}


