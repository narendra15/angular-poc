import { Component, OnInit, Output, EventEmitter } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule, FormControl } from '@angular/forms';

import { MatTableModule } from '@angular/material/table';
import { MatButtonModule } from '@angular/material/button';
import { MatTooltipModule } from '@angular/material/tooltip';

interface GridColumn {
  columnKey: string;
  header: string;
  options: string[];
  tooltip: string;
  meta: {
    targetDatabaseType: string;
    targetDatabase: string;
    targetSchema: string;
    targetTable: string;
    targetTableType: string;
  };
}

interface KeyColumnRow {
  index: number;
  isDraft: boolean;
  values: Record<string, string>;
  controls: Record<string, FormControl>;
  errors?: Record<string, string>;
}

@Component({
  selector: 'app-add-key-column',
  standalone: true,
  templateUrl: './add-key-column.component.html',
  imports: [
    CommonModule,
    FormsModule,
    MatTableModule,
    MatButtonModule,
    MatTooltipModule
  ]
})
export class AddKeyColumnComponent implements OnInit {

  /* ---------------- OUTPUT ---------------- */
  @Output() saveKeyColumns = new EventEmitter<any[][]>();

  /* ---------------- STATE ---------------- */
  columns: GridColumn[] = [];
  rows: KeyColumnRow[] = [];
  displayedColumns: string[] = [];

  maxRows = 10;
  isLoading = true;

  /* ---------------- INIT ---------------- */
  ngOnInit(): void {
    this.loadData();
  }

  /* ---------------- MOCK LOAD (replace with APIs) ---------------- */

  loadData(): void {
    const gridData = [
      {
        target_database_type: 'redshift',
        target_database: 'dev_rfdh',
        target_schema: 'l3_ifrsg',
        target_table: 'fcy_clt',
        target_table_type: 'fact',
        key_columns: 'actv_ind, bsn_dt'
      },
      {
        target_database_type: 'redshift',
        target_database: 'bpa_preprd_11_s3_rfdh',
        target_schema: 'l1_sap_s4_rfdh',
        target_table: '11_ref_sap_s4_lu_tp_fs_ac_grp',
        target_table_type: 'dimension',
        key_columns: 'etl_audit_id, etl_timestamp'
      }
    ];

    const existingMappings = [];

    this.columns = this.buildColumns(gridData);
    this.rows = this.buildExistingRows(existingMappings);

    this.displayedColumns = [
      'mapping',
      ...this.columns.map(c => c.columnKey),
      'actions'
    ];

    if (!this.rows.length) {
      this.addDraftRow();
    }

    this.isLoading = false;
  }

  /* ---------------- BUILD COLUMNS ---------------- */

  buildColumns(data: any[]): GridColumn[] {
    return data.map(item => {
      const columnKey = [
        item.target_database_type,
        item.target_database,
        item.target_schema,
        item.target_table
      ].join('|');

      return {
        columnKey,
        header: item.target_table,
        options: item.key_columns.split(',').map((v: string) => v.trim()),
        tooltip: `Database: ${item.target_database}\nSchema: ${item.target_schema}`,
        meta: {
          targetDatabaseType: item.target_database_type,
          targetDatabase: item.target_database,
          targetSchema: item.target_schema,
          targetTable: item.target_table,
          targetTableType: item.target_table_type
        }
      };
    });
  }

  /* ---------------- EXISTING ROWS ---------------- */

  buildExistingRows(data: any[]): KeyColumnRow[] {
    return [];
  }

  /* ---------------- ADD / CANCEL ---------------- */

  addDraftRow(): void {
    if (this.rows.length >= this.maxRows) return;

    const controls: Record<string, FormControl> = {};
    this.columns.forEach(col => {
      controls[col.columnKey] = new FormControl(null);
    });

    const newRow: KeyColumnRow = {
      index: this.rows.length + 1,
      isDraft: true,
      values: {},
      controls,
      errors: {}
    };

    this.rows = [...this.rows, newRow];
  }

  cancelRow(rowIndex: number): void {
    this.rows = this.rows
      .filter(r => r.index !== rowIndex)
      .map((r, i) => ({ ...r, index: i + 1 }));
  }

  /* ---------------- UNIQUENESS ENFORCEMENT ---------------- */

  private getUsedValuesForColumn(
    columnKey: string,
    currentRow: KeyColumnRow
  ): string[] {
    return this.rows
      .filter(r => r !== currentRow)
      .map(r => r.values[columnKey])
      .filter(Boolean);
  }

  onSelectionChange(
    row: KeyColumnRow,
    columnKey: string,
    value: string
  ): void {

    const usedValues = this.getUsedValuesForColumn(columnKey, row);

    if (usedValues.includes(value)) {
      // ❌ Duplicate selection – revert
      row.controls[columnKey].setValue(null, { emitEvent: false });
      delete row.values[columnKey];

      row.errors![columnKey] =
        'This key column is already selected in another row';

      return;
    }

    // ✅ Valid selection
    delete row.errors?.[columnKey];
    row.values[columnKey] = value;
  }

  /* ---------------- SAVE ---------------- */

  saveAll(): void {
    const payload = this.buildKeyColumnsPayload();
    if (!payload.length) return;

    this.saveKeyColumns.emit(payload);

    this.rows = this.rows.map(r =>
      r.isDraft ? { ...r, isDraft: false } : r
    );
  }

  buildKeyColumnsPayload(): any[][] {
    return this.rows
      .filter(r => r.isDraft)
      .map(row =>
        Object.entries(row.values).map(([columnKey, value]) => {
          const col = this.columns.find(c => c.columnKey === columnKey)!;

          return {
            target_database_type: col.meta.targetDatabaseType,
            target_database: col.meta.targetDatabase,
            target_schema: col.meta.targetSchema,
            target_table: col.meta.targetTable,
            target_table_type: col.meta.targetTableType,
            target_table_key_column: value
          };
        })
      );
  }

  /* ---------------- HELPERS ---------------- */

  get hasDraftRows(): boolean {
    return this.rows.some(r => r.isDraft);
  }

  get isSaveDisabled(): boolean {
    return this.rows
      .filter(r => r.isDraft)
      .some(r =>
        this.columns.some(c => !r.values[c.columnKey])
      );
  }
}





//// HTML ////





<div *ngIf="!isLoading">

  <table mat-table [dataSource]="rows" class="mat-elevation-z1">

    <!-- Mapping Column -->
    <ng-container matColumnDef="mapping">
      <th mat-header-cell *matHeaderCellDef>
        Target Tables
      </th>
      <td mat-cell *matCellDef="let row">
        Key Mapping {{ row.index }}
      </td>
    </ng-container>

    <!-- Dynamic Columns -->
    <ng-container *ngFor="let col of columns" [matColumnDef]="col.columnKey">

      <th
        mat-header-cell
        *matHeaderCellDef
        [matTooltip]="col.tooltip"
        matTooltipPosition="above">
        {{ col.header }}
      </th>

      <td mat-cell *matCellDef="let row">

        <!-- Draft -->
        <ng-container *ngIf="row.isDraft; else readOnly">
          <bmo-select-box
            [label]="''"
            [options]="col.options"
            [internalControl]="row.controls[col.columnKey]"
            (valueChange)="onSelectionChange(row, col.columnKey, $event)">
          </bmo-select-box>
        </ng-container>

        <!-- Read only -->
        <ng-template #readOnly>
          {{ row.values[col.columnKey] }}
        </ng-template>

      </td>

    </ng-container>

    <!-- Actions -->
    <ng-container matColumnDef="actions">
      <th mat-header-cell *matHeaderCellDef></th>
      <td mat-cell *matCellDef="let row">
        <button
          *ngIf="row.isDraft"
          mat-button
          color="warn"
          (click)="cancelRow(row.index)">
          Cancel
        </button>
      </td>
    </ng-container>

    <tr mat-header-row *matHeaderRowDef="displayedColumns"></tr>
    <tr mat-row *matRowDef="let row; columns: displayedColumns"></tr>

  </table>

  <!-- Footer actions -->
  <div style="margin-top:16px; display:flex; gap:12px">
    <button
      mat-raised-button
      color="primary"
      (click)="saveAll()"
      [disabled]="!hasDraftRows || isSaveDisabled">
      Save
    </button>

    <button
      mat-stroked-button
      color="primary"
      (click)="addDraftRow()"
      [disabled]="rows.length >= maxRows">
      Add another
    </button>
  </div>

</div>



