import { Component, EventEmitter, OnInit, Output } from '@angular/core';
import {
  AbstractControl,
  FormArray,
  FormBuilder,
  FormControl,
  FormGroup,
  ValidationErrors,
  ValidatorFn,
  Validators,
} from '@angular/forms';

type Nullable<T> = T | null;
type AnyObj = Record<string, any>;
type TableColumnMap<T> = Record<string, Record<string, T>>;

/** ===== API META (new structure) =====
 * table_name: {
 *   column_name: { meta fields... }
 * }
 */
export interface MetaField {
  ordinal_position: Nullable<number>;
  is_nullable: Nullable<string>; // "YES" | "NO" etc
  data_type: Nullable<string>; // "bigint" | "character varying" | ...
  character_maximum_length: Nullable<number>;
  numeric_precision: Nullable<number>;
  numeric_scale: Nullable<number>;
  column_name: Nullable<string>;
  table_name: Nullable<string>;
  is_key_mapped: Nullable<boolean>;
}
export type ApiMetaData = TableColumnMap<MetaField>;

/** ===== EXISTING DATA (same structure) ===== */
export interface ExistingFieldData {
  system_field_name: Nullable<string>; // UI Field name
  form_field: Nullable<string>;
  field_category: Nullable<string>;
  field_requirement: Nullable<string>;
  dependent_field: Nullable<string>;
  field_default_value: Nullable<string>;
  field_editable: Nullable<string>; // Yes/No
  field_validation_rule_exists: Nullable<string>; // Yes/No
  field_derivation_rule_exists: Nullable<string>; // Yes/No
  field_allowed_values: Nullable<string>; // STANDARD_VALUES | NOT_APPLICABLE
  field_standard_values: Nullable<string>; // comma string
  field_position_in_template: Nullable<number>;
}
export type ExistingData = TableColumnMap<ExistingFieldData>;

/** ===== Options ===== */
type OptionInput = string | { value: any; label: string };

@Component({
  selector: 'app-field-definition-grid',
  template: '', // <-- you already have HTML; keep this TS copy-paste ready
})
export class FieldDefinitionGridComponent implements OnInit {
  @Output() payloadChange = new EventEmitter<ApiMetaData>(); // emits final payload structure

  /** Feature flags */
  enableExistingRows = false;     // when false => existing rows readonly for user inputs
  allowPartialSave = false;       // future: true => allow save only valid rows

  /** ---------- SAMPLE DATA (NEW API STRUCTURE) ---------- */
  metaApiData: ApiMetaData = {
    fcy_clt: {
      idp_warehouse_id: {
        ordinal_position: 1,
        is_nullable: 'YES',
        data_type: 'bigint',
        character_maximum_length: null,
        numeric_precision: 64,
        numeric_scale: 0,
        column_name: 'idp_warehouse_id',
        table_name: 'fcy_clt',
        is_key_mapped: false,
      },
      prim_clt_ind: {
        ordinal_position: 18,
        is_nullable: 'YES',
        data_type: 'character varying',
        character_maximum_length: 65535,
        numeric_precision: null,
        numeric_scale: null,
        column_name: 'prim_clt_ind',
        table_name: 'fcy_clt',
        is_key_mapped: false,
      },
    },
    l1_ref_sap_s4_lu_tp_fs_ac_grp: {
      idp_warehouse_id: {
        ordinal_position: 1,
        is_nullable: 'NO',
        data_type: 'bigint',
        character_maximum_length: null,
        numeric_precision: 64,
        numeric_scale: 0,
        column_name: 'idp_warehouse_id',
        table_name: 'l1_ref_sap_s4_lu_tp_fs_ac_grp',
        is_key_mapped: false,
      },
      idp_audit_id: {
        ordinal_position: 2,
        is_nullable: 'NO',
        data_type: 'bigint',
        character_maximum_length: null,
        numeric_precision: 64,
        numeric_scale: 0,
        column_name: 'idp_audit_id',
        table_name: 'l1_ref_sap_s4_lu_tp_fs_ac_grp',
        is_key_mapped: false,
      },
    },
  };

  /** Existing user-defined config (same structure) */
  existingData: ExistingData = {
    fcy_clt: {
      idp_warehouse_id: {
        system_field_name: 'RPT_DATA_DATE',
        form_field: 'Date picker',
        field_category: 'User',
        field_requirement: 'Mandatory',
        dependent_field: null,
        field_default_value: null,
        field_editable: 'Yes',
        field_validation_rule_exists: 'Yes',
        field_derivation_rule_exists: 'Yes',
        field_allowed_values: 'NOT_APPLICABLE',
        field_standard_values: null,
        field_position_in_template: 1,
      },
    },
  };

  /** ---------- FORM ---------- */
  form!: FormGroup;
  get rows(): FormArray<FormGroup> {
    return this.form.get('rows') as FormArray<FormGroup>;
  }

  /** ---------- DROPDOWN OPTIONS ---------- */
  formFieldOptions: OptionInput[] = ['Free text', 'Radio button', 'Drop down', 'Date picker'];
  fieldCategoryOptions: OptionInput[] = ['User', 'Derived'];
  fieldRequirementOptions: OptionInput[] = ['Mandatory', 'Conditionally mandatory', 'Optional'];
  yesNoOptions: OptionInput[] = ['Yes', 'No'];
  allowedValuesOptions: OptionInput[] = ['STANDARD_VALUES', 'NOT_APPLICABLE'];

  /** Columns list for your mat-table */
  displayedColumns: string[] = [
    'table_name',
    'column_name',
    'system_field_name',
    'form_field',
    'field_category',
    'field_requirement',
    'dependent_field',
    'data_type',
    'character_maximum_length',
    'numeric_precision',
    'numeric_scale',
    'field_default_value',
    'field_editable',
    'field_validation_rule_exists',
    'field_derivation_rule_exists',
    'field_allowed_values',
    'field_standard_values',
    'field_position_in_template',
  ];

  constructor(private fb: FormBuilder) {}

  ngOnInit(): void {
    this.form = this.fb.group({
      rows: this.fb.array([]),
    });

    this.buildRowsFromApi();
  }

  /** ---------- BUILD ROWS ---------- */
  private buildRowsFromApi(): void {
    this.rows.clear();

    Object.entries(this.metaApiData).forEach(([tableName, cols]) => {
      Object.entries(cols).forEach(([columnName, meta]) => {
        const existing = this.existingData?.[tableName]?.[columnName] ?? null;
        const row = this.createRow(tableName, columnName, meta, existing);
        this.rows.push(row);
        this.wireRowRules(row);
        this.applyExistingEditState(row, !!existing);
      });
    });

    // After all rows exist => refresh uniqueness/dependent options validity
    this.refreshCrossRowValidity();
  }

  private createRow(
    tableName: string,
    columnName: string,
    meta: MetaField,
    existing: ExistingFieldData | null
  ): FormGroup {
    const isExisting = !!existing;

    const fg = this.fb.group({
      /** keys */
      table_name: new FormControl({ value: tableName, disabled: true }),
      column_name: new FormControl({ value: columnName, disabled: true }),

      /** meta (read-only in UI, but included in payload) */
      ordinal_position: new FormControl({ value: meta?.ordinal_position ?? null, disabled: true }),
      is_nullable: new FormControl({ value: meta?.is_nullable ?? null, disabled: true }),
      data_type: new FormControl({ value: meta?.data_type ?? null, disabled: true }),
      character_maximum_length: new FormControl({ value: meta?.character_maximum_length ?? null, disabled: true }),
      numeric_precision: new FormControl({ value: meta?.numeric_precision ?? null, disabled: true }),
      numeric_scale: new FormControl({ value: meta?.numeric_scale ?? null, disabled: true }),
      is_key_mapped: new FormControl({ value: meta?.is_key_mapped ?? null, disabled: true }),

      /** user inputs */
      system_field_name: new FormControl(
        existing?.system_field_name ?? null,
        [
          Validators.required,
          Validators.minLength(5),
          Validators.maxLength(50),
          Validators.pattern(/^[A-Za-z ]+$/),
          this.uniqueUiFieldNameValidator(), // cross-row
        ]
      ),

      form_field: new FormControl(existing?.form_field ?? null, [Validators.required]),
      field_category: new FormControl(existing?.field_category ?? null, [Validators.required]),

      field_requirement: new FormControl(
        { value: existing?.field_requirement ?? null, disabled: false },
        [] // applied via rules
      ),

      dependent_field: new FormControl({ value: existing?.dependent_field ?? null, disabled: true }),

      field_default_value: new FormControl(
        existing?.field_default_value ?? null,
        [this.defaultValueByDataTypeValidator()]
      ),

      field_editable: new FormControl(existing?.field_editable ?? 'Yes', [Validators.required]),
      field_validation_rule_exists: new FormControl(existing?.field_validation_rule_exists ?? 'No', [Validators.required]),
      field_derivation_rule_exists: new FormControl(existing?.field_derivation_rule_exists ?? 'No', [Validators.required]),

      field_allowed_values: new FormControl({ value: existing?.field_allowed_values ?? 'NOT_APPLICABLE', disabled: true }),
      field_standard_values: new FormControl(
        { value: existing?.field_standard_values ?? null, disabled: true },
        [this.standardValuesValidator()]
      ),

      field_position_in_template: new FormControl(existing?.field_position_in_template ?? null, [
        Validators.required,
        Validators.pattern(/^\d+$/),
      ]),

      /** internal flags */
      _isExisting: new FormControl(isExisting),
    });

    // initial rule application
    this.applyCategoryRule(fg);
    this.applyRequirementRule(fg);
    this.applyAllowedValuesRule(fg);
    this.applyStandardValuesRule(fg);

    return fg;
  }

  /** ---------- RULES WIRING ---------- */
  private wireRowRules(row: FormGroup): void {
    row.get('field_category')?.valueChanges.subscribe(() => {
      this.applyCategoryRule(row);
      this.applyRequirementRule(row);
    });

    row.get('field_requirement')?.valueChanges.subscribe(() => {
      this.applyRequirementRule(row);
      this.refreshCrossRowValidity();
    });

    row.get('system_field_name')?.valueChanges.subscribe(() => {
      this.refreshCrossRowValidity();
    });

    row.get('field_default_value')?.valueChanges.subscribe(() => {
      this.applyAllowedValuesRule(row);
      this.applyStandardValuesRule(row);
    });

    row.get('field_allowed_values')?.valueChanges.subscribe(() => {
      this.applyStandardValuesRule(row);
    });
  }

  private applyCategoryRule(row: FormGroup): void {
    const cat = (row.get('field_category')?.value ?? '').toString();
    const reqCtrl = row.get('field_requirement');

    if (!reqCtrl) return;

    if (cat === 'Derived') {
      reqCtrl.disable({ emitEvent: false });
      reqCtrl.setValue(null, { emitEvent: false });
      reqCtrl.clearValidators();
      reqCtrl.updateValueAndValidity({ emitEvent: false });
    } else {
      reqCtrl.enable({ emitEvent: false });
      reqCtrl.setValidators([Validators.required]);
      reqCtrl.updateValueAndValidity({ emitEvent: false });
    }
  }

  private applyRequirementRule(row: FormGroup): void {
    const req = (row.get('field_requirement')?.value ?? '').toString();
    const depCtrl = row.get('dependent_field');

    if (!depCtrl) return;

    const options = this.getDependentOptionsForRow(row);
    const hasOptions = options.length > 0;

    if (req === 'Conditionally mandatory' && hasOptions) {
      depCtrl.enable({ emitEvent: false });
      depCtrl.setValidators([Validators.required]);
    } else {
      depCtrl.disable({ emitEvent: false });
      depCtrl.setValue(null, { emitEvent: false });
      depCtrl.clearValidators();
    }
    depCtrl.updateValueAndValidity({ emitEvent: false });
  }

  private applyAllowedValuesRule(row: FormGroup): void {
    const defVal = (row.get('field_default_value')?.value ?? '').toString().trim();
    const allowedCtrl = row.get('field_allowed_values');

    if (!allowedCtrl) return;

    if (defVal.length > 0) {
      allowedCtrl.enable({ emitEvent: false });
      if (!allowedCtrl.value) allowedCtrl.setValue('NOT_APPLICABLE', { emitEvent: false });
      allowedCtrl.setValidators([Validators.required]);
    } else {
      allowedCtrl.disable({ emitEvent: false });
      allowedCtrl.setValue('NOT_APPLICABLE', { emitEvent: false });
      allowedCtrl.clearValidators();
      // also clear standard values when default empty
      row.get('field_standard_values')?.setValue(null, { emitEvent: false });
    }

    allowedCtrl.updateValueAndValidity({ emitEvent: false });
  }

  private applyStandardValuesRule(row: FormGroup): void {
    const allowed = (row.get('field_allowed_values')?.value ?? '').toString();
    const stdCtrl = row.get('field_standard_values');

    if (!stdCtrl) return;

    if (allowed === 'STANDARD_VALUES') {
      stdCtrl.enable({ emitEvent: false });
      stdCtrl.setValidators([Validators.required, this.standardValuesValidator()]);
    } else {
      stdCtrl.disable({ emitEvent: false });
      stdCtrl.setValue(null, { emitEvent: false });
      stdCtrl.clearValidators();
    }
    stdCtrl.updateValueAndValidity({ emitEvent: false });
  }

  /** Existing rows editable toggle */
  private applyExistingEditState(row: FormGroup, isExisting: boolean): void {
    if (!isExisting) return;

    const shouldDisable = !this.enableExistingRows;

    const userInputKeys: string[] = [
      'system_field_name',
      'form_field',
      'field_category',
      'field_requirement',
      'dependent_field',
      'field_default_value',
      'field_editable',
      'field_validation_rule_exists',
      'field_derivation_rule_exists',
      'field_allowed_values',
      'field_standard_values',
      'field_position_in_template',
    ];

    userInputKeys.forEach((k: string) => {
      const c = row.get(k);
      if (!c) return;
      if (shouldDisable) c.disable({ emitEvent: false });
      else c.enable({ emitEvent: false });
    });
  }

  /** ---------- DEPENDENT OPTIONS ---------- */
  getDependentOptionsForRow(row: FormGroup): string[] {
    // Enabled only if there is at least one other valid UI name
    const current = (row.get('system_field_name')?.value ?? '').toString().trim();
    const all = this.rows.controls
      .map((r) => (r.get('system_field_name')?.value ?? '').toString().trim())
      .filter((v) => v.length > 0);

    // can't refer to itself
    const candidates = all.filter((v) => v !== current);

    // unique list
    return Array.from(new Set(candidates));
  }

  /** Call after any UI field name changes */
  private refreshCrossRowValidity(): void {
    // refresh uniqueness on all rows
    this.rows.controls.forEach((r) => {
      r.get('system_field_name')?.updateValueAndValidity({ emitEvent: false });
    });

    // refresh dependent enable/validators
    this.rows.controls.forEach((r) => {
      this.applyRequirementRule(r);
    });
  }

  /** ---------- VALIDATORS ---------- */
  private uniqueUiFieldNameValidator(): ValidatorFn {
    return (control: AbstractControl): ValidationErrors | null => {
      const val = (control.value ?? '').toString().trim();
      if (!val) return null;

      // gather all names across rows
      const all = (this.form?.get('rows') as FormArray | null)?.controls
        ?.map((r) => (r.get('system_field_name')?.value ?? '').toString().trim())
        ?? [];

      const dupCount = all.filter((x: string) => x === val).length;
      if (dupCount > 1) return { notUniqueUiFieldName: true };

      return null;
    };
  }

  private defaultValueByDataTypeValidator(): ValidatorFn {
    return (control: AbstractControl): ValidationErrors | null => {
      const val = (control.value ?? '').toString();
      if (!val) return null; // can be null

      const row = control.parent as FormGroup | null;
      const dataType = (row?.get('data_type')?.value ?? '').toString().toLowerCase();

      // a) character varying => allow A-Z a-z 0-9 only
      if (dataType.includes('character')) {
        return /^[A-Za-z0-9]+$/.test(val) ? null : { invalidDefaultValue: true };
      }

      // b) number types => digits only
      if (dataType.includes('int') || dataType.includes('numeric') || dataType.includes('decimal')) {
        return /^\d+$/.test(val) ? null : { invalidDefaultValue: true };
      }

      // otherwise allow anything (safe default)
      return null;
    };
  }

  private standardValuesValidator(): ValidatorFn {
    return (control: AbstractControl): ValidationErrors | null => {
      const raw = (control.value ?? '').toString().trim();
      if (!raw) return null; // required handled elsewhere

      const parts = raw.split(',').map((p) => p.trim()).filter(Boolean);
      if (parts.length > 10) return { maxStandardValues: true };

      // Each token must be:
      // - numeric (digits) OR
      // - alphanumeric/alphabetic wrapped in quotes "ABC12"
      for (const p of parts) {
        const isNumber = /^\d+$/.test(p);
        const isQuotedAlphaNum = /^"[\w\d\s]+"$/.test(p); // allow spaces inside quotes too
        if (!isNumber && !isQuotedAlphaNum) return { invalidStandardValue: true };
      }
      return null;
    };
  }

  /** ---------- INLINE ERROR HELPERS (use in HTML) ---------- */
  getControl(i: number, key: string): AbstractControl | null {
    return this.rows.at(i)?.get(key) ?? null;
  }

  hasError(i: number, key: string, errorKey: string): boolean {
    const c = this.getControl(i, key);
    return !!(c && c.touched && c.invalid && c.hasError(errorKey));
  }

  showAnyError(i: number, key: string): boolean {
    const c = this.getControl(i, key);
    return !!(c && c.touched && c.invalid);
  }

  /** ---------- SAVE ---------- */
  save(): void {
    // All rows saved together (current behavior)
    this.form.markAllAsTouched();
    this.refreshCrossRowValidity();

    if (this.form.invalid) {
      if (!this.allowPartialSave) {
        console.log('Save Failed (form invalid)');
        return;
      }

      // future: partial save
      const payload = this.buildPayload({ partial: true });
      this.payloadChange.emit(payload);
      console.log('PARTIAL PAYLOAD', payload);
      return;
    }

    const payload = this.buildPayload({ partial: false });
    this.payloadChange.emit(payload);
    console.log('FINAL PAYLOAD', payload);
  }

  /** Build payload in SAME STRUCTURE: table -> column -> { meta + user inputs } */
  private buildPayload(opts: { partial: boolean }): ApiMetaData {
    const out: AnyObj = {};

    this.rows.controls.forEach((row) => {
      // partial: only include valid rows
      if (opts.partial && row.invalid) return;

      // include disabled values as well
      const v = row.getRawValue();

      const table = v.table_name;
      const col = v.column_name;

      out[table] = out[table] ?? {};

      out[table][col] = {
        // meta (as is)
        ordinal_position: v.ordinal_position ?? null,
        is_nullable: v.is_nullable ?? null,
        data_type: v.data_type ?? null,
        character_maximum_length: v.character_maximum_length ?? null,
        numeric_precision: v.numeric_precision ?? null,
        numeric_scale: v.numeric_scale ?? null,
        column_name: v.column_name ?? null,
        table_name: v.table_name ?? null,
        is_key_mapped: v.is_key_mapped ?? null,

        // user inputs
        system_field_name: v.system_field_name ?? null,
        form_field: v.form_field ?? null,
        field_category: v.field_category ?? null,
        field_requirement: v.field_requirement ?? null,
        dependent_field: v.dependent_field ?? null,
        field_default_value: v.field_default_value ?? null,
        field_editable: v.field_editable ?? null,
        field_validation_rule_exists: v.field_validation_rule_exists ?? null,
        field_derivation_rule_exists: v.field_derivation_rule_exists ?? null,
        field_allowed_values: v.field_allowed_values ?? null,
        field_standard_values: v.field_standard_values ?? null,
        field_position_in_template: v.field_position_in_template ?? null,
      };
    });

    return out as ApiMetaData;
  }

  /** Call this if you toggle flags at runtime */
  refreshEditModeForExistingRows(): void {
    this.rows.controls.forEach((r) => {
      const isExisting = !!r.get('_isExisting')?.value;
      this.applyExistingEditState(r, isExisting);
    });
  }
}





////////////// HTML //////////////////


<form [formGroup]="form" class="fd-form">
  <div class="table-wrap">
    <table mat-table [dataSource]="rows.controls" formArrayName="rows" class="fd-table">

      <ng-container *ngFor="let col of displayedColumns" [matColumnDef]="col">
        <th mat-header-cell *matHeaderCellDef class="sticky-header">
          {{ columnLabels[col] || col }}
        </th>

        <td
          mat-cell
          *matCellDef="let row; let i = index"
          [formGroupName]="i"
          [class.invalid-row]="rowHasErrors(i)"
        >
          <!-- READONLY TEXT CELLS -->
          <ng-container *ngIf="col === 'tableName'">
            {{ (rows.at(i) as any).get('table_name').value }}
          </ng-container>

          <ng-container *ngIf="col === 'columnName'">
            {{ (rows.at(i) as any).get('column_name').value }}
          </ng-container>

          <ng-container *ngIf="col === 'dataType'">
            {{ (rows.at(i) as any).get('data_type').value }}
          </ng-container>

          <ng-container *ngIf="col === 'maxLength'">
            {{ (rows.at(i) as any).get('character_maximum_length').value }}
          </ng-container>

          <ng-container *ngIf="col === 'numericPrecision'">
            {{ (rows.at(i) as any).get('numeric_precision').value }}
          </ng-container>

          <ng-container *ngIf="col === 'numericScale'">
            {{ (rows.at(i) as any).get('numeric_scale').value }}
          </ng-container>

          <!-- INPUTS -->
          <ng-container *ngIf="col === 'systemFieldName'">
            <mat-form-field appearance="outline" class="cell-field">
              <input matInput formControlName="system_field_name" />
              <mat-error *ngIf="isInvalid(i, 'system_field_name')">
                {{ getError(i, 'system_field_name') }}
              </mat-error>
            </mat-form-field>
          </ng-container>

          <ng-container *ngIf="col === 'defaultValue'">
            <mat-form-field appearance="outline" class="cell-field">
              <input matInput formControlName="field_default_value" />
              <mat-error *ngIf="isInvalid(i, 'field_default_value')">
                {{ getError(i, 'field_default_value') }}
              </mat-error>
            </mat-form-field>
          </ng-container>

          <ng-container *ngIf="col === 'standardValues'">
            <mat-form-field appearance="outline" class="cell-field">
              <input matInput formControlName="field_standard_values" />
              <mat-error *ngIf="isInvalid(i, 'field_standard_values')">
                {{ getError(i, 'field_standard_values') }}
              </mat-error>
            </mat-form-field>
          </ng-container>

          <ng-container *ngIf="col === 'positionInTemplate'">
            <mat-form-field appearance="outline" class="cell-field">
              <input matInput type="number" formControlName="field_position_in_template" />
              <mat-error *ngIf="isInvalid(i, 'field_position_in_template')">
                {{ getError(i, 'field_position_in_template') }}
              </mat-error>
            </mat-form-field>
          </ng-container>

          <!-- DROPDOWNS (BMO SELECT) -->
          <ng-container *ngIf="col === 'formField'">
            <bmo-select-box
              [options]="formFieldOptions"
              [internalControl]="(rows.at(i) as any).get('form_field')"
              [errorMessage]="getError(i, 'form_field')">
            </bmo-select-box>
          </ng-container>

          <ng-container *ngIf="col === 'fieldCategory'">
            <bmo-select-box
              [options]="fieldCategoryOptions"
              [internalControl]="(rows.at(i) as any).get('field_category')"
              [errorMessage]="getError(i, 'field_category')">
            </bmo-select-box>
          </ng-container>

          <ng-container *ngIf="col === 'fieldRequirement'">
            <bmo-select-box
              [options]="fieldRequirementOptions"
              [internalControl]="(rows.at(i) as any).get('field_requirement')"
              [errorMessage]="getError(i, 'field_requirement')">
            </bmo-select-box>
          </ng-container>

          <ng-container *ngIf="col === 'dependentField'">
            <bmo-select-box
              [options]="getDependentOptions(i)"
              [internalControl]="(rows.at(i) as any).get('dependent_field')"
              [errorMessage]="getError(i, 'dependent_field')">
            </bmo-select-box>
          </ng-container>

          <ng-container *ngIf="col === 'editableByUser'">
            <bmo-select-box
              [options]="yesNoOptions"
              [internalControl]="(rows.at(i) as any).get('field_editable')"
              [errorMessage]="getError(i, 'field_editable')">
            </bmo-select-box>
          </ng-container>

          <ng-container *ngIf="col === 'validationRuleExists'">
            <bmo-select-box
              [options]="yesNoOptions"
              [internalControl]="(rows.at(i) as any).get('field_validation_rule_exists')"
              [errorMessage]="getError(i, 'field_validation_rule_exists')">
            </bmo-select-box>
          </ng-container>

          <ng-container *ngIf="col === 'derivationRuleExists'">
            <bmo-select-box
              [options]="yesNoOptions"
              [internalControl]="(rows.at(i) as any).get('field_derivation_rule_exists')"
              [errorMessage]="getError(i, 'field_derivation_rule_exists')">
            </bmo-select-box>
          </ng-container>

          <ng-container *ngIf="col === 'allowedValues'">
            <bmo-select-box
              [options]="allowedValuesOptions"
              [internalControl]="(rows.at(i) as any).get('field_allowed_values')"
              [errorMessage]="getError(i, 'field_allowed_values')">
            </bmo-select-box>
          </ng-container>
        </td>
      </ng-container>

      <tr mat-header-row *matHeaderRowDef="displayedColumns; sticky: true"></tr>
      <tr mat-row *matRowDef="let r; columns: displayedColumns"></tr>
    </table>
  </div>

  <div class="actions">
    <button mat-raised-button color="primary" (click)="save()">Save</button>
  </div>
</form>



/////////// CSS //////////////


.table-wrap {
  overflow: auto;
  max-width: 100%;
  border: 1px solid #e0e0e0;
}

.fd-table {
  min-width: 1800px;
}

.cell-field {
  width: 180px;
}

.invalid-row {
  outline: 2px solid #d32f2f;
  outline-offset: -2px;
  background: rgba(211, 47, 47, 0.04);
}

.actions {
  margin-top: 12px;
}
