import { Component, OnInit } from '@angular/core';
import {
  AbstractControl,
  FormArray,
  FormBuilder,
  FormGroup,
  Validators
} from '@angular/forms';

@Component({
  selector: 'app-field-definition-grid',
  templateUrl: './field-definition-grid.html'
})
export class FieldDefinitionGridComponent implements OnInit {
  form!: FormGroup;
  enableExistingRows = false;

  /* ================= OPTIONS (REQUIRED BY TEMPLATE) ================= */

  formFieldOptions = [
    'Free text',
    'Radio button',
    'Drop down',
    'Date picker'
  ];

  fieldCategoryOptions = ['User', 'Derived'];

  fieldRequirementOptions = [
    'Mandatory',
    'Conditionally mandatory',
    'Optional'
  ];

  yesNoOptions = ['Yes', 'No'];

  allowedValuesOptions = [
    'STANDARD_VALUES',
    'NOT_APPLICABLE'
  ];

  displayedColumns = [
    'tableName',
    'columnName',
    'uiFieldName',
    'formField',
    'fieldCategory',
    'fieldRequirement',
    'dependentField',
    'defaultValue',
    'editableByUser',
    'validationRuleExists',
    'derivationRuleExists',
    'allowedValues',
    'standardValues',
    'positionInTemplate'
  ];

  constructor(private fb: FormBuilder) {}

  ngOnInit(): void {
    this.form = this.fb.group({
      rows: this.fb.array([])
    });

    // Example usage:
    // this.addRow(meta, existingData);
  }

  get rows(): FormArray {
    return this.form.get('rows') as FormArray;
  }

  /* ================= ROW CREATION ================= */

  addRow(meta: any, existing?: any): void {
    const row = this.createRow(meta, existing);
    this.rows.push(row);
    this.wireRowSubscriptions(row);
  }

  private createRow(meta: any, existing?: any): FormGroup {
    const fg = this.fb.group({
      tableName: [{ value: meta.tableName, disabled: true }],
      columnName: [{ value: meta.columnName, disabled: true }],

      uiFieldName: [
        existing?.system_field_name ?? null,
        [
          Validators.required,
          Validators.minLength(5),
          Validators.maxLength(50),
          Validators.pattern(/^[A-Za-z ]+$/)
        ]
      ],

      formField: [existing?.form_field ?? null, Validators.required],
      fieldCategory: [existing?.field_category ?? null, Validators.required],

      fieldRequirement: [existing?.field_requirement ?? null],
      dependentField: [existing?.dependent_field ?? null],

      defaultValue: [existing?.field_default_value ?? null],

      editableByUser: [
        existing?.field_editable ?? 'Yes',
        Validators.required
      ],
      validationRuleExists: [
        existing?.field_validation_rule_exists ?? 'No',
        Validators.required
      ],
      derivationRuleExists: [
        existing?.field_derivation_rule_exists ?? 'No',
        Validators.required
      ],

      allowedValues: [
        existing?.field_allowed_values ?? 'NOT_APPLICABLE'
      ],
      standardValues: [existing?.field_standard_values ?? null],

      positionInTemplate: [
        existing?.field_position_in_template ?? null,
        Validators.required
      ]
    });

    this.applyRowRules(fg);

    if (existing && !this.enableExistingRows) {
      fg.disable({ emitEvent: false });
    }

    return fg;
  }

  /* ================= RULE ENGINE ================= */

  private applyRowRules(row: FormGroup): void {
    const categoryCtrl = row.get('fieldCategory')!;
    const requirementCtrl = row.get('fieldRequirement')!;
    const dependentCtrl = row.get('dependentField')!;
    const allowedCtrl = row.get('allowedValues')!;
    const standardCtrl = row.get('standardValues')!;

    // Field Requirement
    if (categoryCtrl.value === 'Derived') {
      requirementCtrl.clearValidators();
      requirementCtrl.setValue(null, { emitEvent: false });
      requirementCtrl.disable({ emitEvent: false });
    } else {
      requirementCtrl.setValidators(Validators.required);
      requirementCtrl.enable({ emitEvent: false });
    }
    requirementCtrl.updateValueAndValidity({ emitEvent: false });

    // Dependent Field
    if (requirementCtrl.value === 'Conditionally mandatory') {
      dependentCtrl.setValidators(Validators.required);
      dependentCtrl.enable({ emitEvent: false });
    } else {
      dependentCtrl.clearValidators();
      dependentCtrl.setValue(null, { emitEvent: false });
      dependentCtrl.disable({ emitEvent: false });
    }
    dependentCtrl.updateValueAndValidity({ emitEvent: false });

    // Standard Values
    if (allowedCtrl.value === 'STANDARD_VALUES') {
      standardCtrl.setValidators([
        Validators.required,
        this.standardValuesValidator()
      ]);
      standardCtrl.enable({ emitEvent: false });
    } else {
      standardCtrl.clearValidators();
      standardCtrl.setValue(null, { emitEvent: false });
      standardCtrl.disable({ emitEvent: false });
    }
    standardCtrl.updateValueAndValidity({ emitEvent: false });
  }

  private wireRowSubscriptions(row: FormGroup): void {
    row.get('fieldCategory')!.valueChanges.subscribe(() =>
      this.applyRowRules(row)
    );
    row.get('fieldRequirement')!.valueChanges.subscribe(() =>
      this.applyRowRules(row)
    );
    row.get('allowedValues')!.valueChanges.subscribe(() =>
      this.applyRowRules(row)
    );
  }

  /* ================= VALIDATOR ================= */

  private standardValuesValidator() {
    return (control: AbstractControl) => {
      if (!control.value) return null;

      const values = control.value
        .split(',')
        .map((v: string) => v.trim())
        .filter(Boolean);

      if (values.length > 10) return { maxStandardValues: true };

      const invalid = values.some(v => {
        if (/^\d+$/.test(v)) return false;
        if (/^".+"$/.test(v)) return false;
        return true;
      });

      return invalid ? { invalidStandardValue: true } : null;
    };
  }

  /* ================= DEPENDENT OPTIONS ================= */

  getDependentOptions(rowIndex: number): string[] {
    return this.rows.controls
      .map((row, idx) =>
        idx !== rowIndex ? row.get('uiFieldName')?.value : null
      )
      .filter(v => !!v);
  }

  /* ================= SAVE ================= */

  save(): void {
    this.form.updateValueAndValidity({ emitEvent: false });

    if (this.form.invalid) {
      console.log('Save Failed');
      this.form.markAllAsTouched();
      return;
    }

    console.log('FINAL PAYLOAD', this.rows.getRawValue());
  }
}





/////////////// HTMl //////////////

<form [formGroup]="form">
  <table
    mat-table
    [dataSource]="rows.controls"
    formArrayName="rows"
    class="mat-elevation-z1"
  >
    <ng-container
      *ngFor="let col of displayedColumns"
      [matColumnDef]="col"
    >
      <th mat-header-cell *matHeaderCellDef>
        {{ col }}
      </th>

      <td
        mat-cell
        *matCellDef="let row; let i = index"
        [formGroupName]="i"
      >
        <!-- READ ONLY -->
        <ng-container
          *ngIf="['tableName','columnName'].includes(col)"
        >
          {{ row.get(col)?.value }}
        </ng-container>

        <!-- INPUT -->
        <input
          *ngIf="['uiFieldName','defaultValue','standardValues','positionInTemplate'].includes(col)"
          matInput
          [formControlName]="col"
        />

        <!-- SELECTS -->
        <bmo-select-box
          *ngIf="col === 'formField'"
          [options]="formFieldOptions"
          formControlName="formField"
        ></bmo-select-box>

        <bmo-select-box
          *ngIf="col === 'fieldCategory'"
          [options]="fieldCategoryOptions"
          formControlName="fieldCategory"
        ></bmo-select-box>

        <bmo-select-box
          *ngIf="col === 'fieldRequirement'"
          [options]="fieldRequirementOptions"
          formControlName="fieldRequirement"
        ></bmo-select-box>

        <bmo-select-box
          *ngIf="col === 'dependentField'"
          [options]="getDependentOptions(i)"
          formControlName="dependentField"
        ></bmo-select-box>

        <bmo-select-box
          *ngIf="col === 'editableByUser'"
          [options]="yesNoOptions"
          formControlName="editableByUser"
        ></bmo-select-box>

        <bmo-select-box
          *ngIf="col === 'validationRuleExists'"
          [options]="yesNoOptions"
          formControlName="validationRuleExists"
        ></bmo-select-box>

        <bmo-select-box
          *ngIf="col === 'derivationRuleExists'"
          [options]="yesNoOptions"
          formControlName="derivationRuleExists"
        ></bmo-select-box>

        <bmo-select-box
          *ngIf="col === 'allowedValues'"
          [options]="allowedValuesOptions"
          formControlName="allowedValues"
        ></bmo-select-box>
      </td>
    </ng-container>

    <tr
      mat-header-row
      *matHeaderRowDef="displayedColumns; sticky: true"
    ></tr>

    <tr
      mat-row
      *matRowDef="let row; columns: displayedColumns"
    ></tr>
  </table>

  <button
    mat-raised-button
    color="primary"
    (click)="save()"
  >
    Save
  </button>
</form>
