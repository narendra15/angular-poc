import { Component, OnInit } from '@angular/core';
import {
  AbstractControl,
  FormArray,
  FormBuilder,
  FormGroup,
  Validators,
} from '@angular/forms';

@Component({
  selector: 'app-field-definition-grid',
  templateUrl: './field-definition-grid.html',
})
export class FieldDefinitionGridComponent implements OnInit {
  form!: FormGroup;
  enableExistingRows = false;

  /* ---------- SAMPLE API DATA (AS PROVIDED) ---------- */

  rowData = {
    bcl_cv: ['eff_ts', 'end_ts'],
    bcl_err_tbl: ['file_name', 'end_ts'],
  };

  metaData: any = {
    bcl_cv: {
      eff_ts: {
        field_data_type: 'character varying',
        field_maximum_length: 50,
        numeric_precision: null,
        numeric_scale: null,
      },
      end_ts: {
        field_data_type: 'bigint',
        field_maximum_length: null,
        numeric_precision: 64,
        numeric_scale: 0,
      },
    },
  };

  existingData: any = {
    bcl_cv: {
      eff_ts: {
        system_field_name: 'RPT_DATA_DATE',
        form_field: 'Date picker',
        field_category: 'User',
        field_requirement: 'Mandatory',
        dependent_field: null,
        field_default_value: null,
        field_editable: 'Yes',
        field_validation_rule_exists: 'Yes',
        field_derivation_rule_exists: 'Yes',
        field_allowed_values: 'NOT_APPLICABLE',
        field_standard_values: null,
        field_position_in_template: 1,
      },
    },
  };

  /* ---------- DROPDOWN OPTIONS ---------- */

  formFieldOptions = ['Free text', 'Radio button', 'Drop down', 'Date picker'];
  fieldCategoryOptions = ['User', 'Derived'];
  fieldRequirementOptions = [
    'Mandatory',
    'Conditionally mandatory',
    'Optional',
  ];
  yesNoOptions = ['Yes', 'No'];
  allowedValuesOptions = ['STANDARD_VALUES', 'NOT_APPLICABLE'];

  displayedColumns = [
    'tableName',
    'columnName',
    'uiFieldName',
    'formField',
    'fieldCategory',
    'fieldRequirement',
    'dependentField',
    'fieldDataType',
    'fieldMaximumLength',
    'numericPrecision',
    'numericScale',
    'defaultValue',
    'editableByUser',
    'validationRuleExists',
    'derivationRuleExists',
    'allowedValues',
    'standardValues',
    'positionInTemplate',
  ];

  constructor(private fb: FormBuilder) {}

  ngOnInit(): void {
    this.form = this.fb.group({
      rows: this.fb.array([]),
    });

    this.buildRowsFromApiData();
  }

  /* ---------- GETTERS ---------- */

  get rows(): FormArray {
    return this.form.get('rows') as FormArray;
  }

  /* ---------- BUILD ROWS FROM API DATA ---------- */

  private buildRowsFromApiData(): void {
    Object.keys(this.rowData).forEach((tableName) => {
      this.rowData[tableName].forEach((columnName) => {
        const meta = this.metaData?.[tableName]?.[columnName];
        const existing = this.existingData?.[tableName]?.[columnName];

        const row = this.createRow(tableName, columnName, meta, existing);
        this.rows.push(row);
        this.wireRowSubscriptions(row);
      });
    });
  }

  private createRow(
    tableName: string,
    columnName: string,
    meta: any,
    existing?: any
  ): FormGroup {
    const fg = this.fb.group({
      tableName: [{ value: tableName, disabled: true }],
      columnName: [{ value: columnName, disabled: true }],

      uiFieldName: [
        existing?.system_field_name ?? null,
        [
          Validators.required,
          Validators.minLength(5),
          Validators.maxLength(50),
          Validators.pattern(/^[A-Za-z ]+$/),
        ],
      ],

      formField: [existing?.form_field ?? null, Validators.required],
      fieldCategory: [
        existing?.field_category ?? null,
        Validators.required,
      ],

      fieldRequirement: [existing?.field_requirement ?? null],
      dependentField: [existing?.dependent_field ?? null],

      fieldDataType: [{ value: meta?.field_data_type ?? null, disabled: true }],
      fieldMaximumLength: [
        { value: meta?.field_maximum_length ?? null, disabled: true },
      ],
      numericPrecision: [
        { value: meta?.numeric_precision ?? null, disabled: true },
      ],
      numericScale: [
        { value: meta?.numeric_scale ?? null, disabled: true },
      ],

      defaultValue: [existing?.field_default_value ?? null],

      editableByUser: [
        existing?.field_editable ?? 'Yes',
        Validators.required,
      ],
      validationRuleExists: [
        existing?.field_validation_rule_exists ?? 'No',
        Validators.required,
      ],
      derivationRuleExists: [
        existing?.field_derivation_rule_exists ?? 'No',
        Validators.required,
      ],

      allowedValues: [
        existing?.field_allowed_values ?? 'NOT_APPLICABLE',
      ],
      standardValues: [existing?.field_standard_values ?? null],

      positionInTemplate: [
        existing?.field_position_in_template ?? null,
        Validators.required,
      ],
    });

    this.applyRowRules(fg);

    if (existing && !this.enableExistingRows) {
      fg.disable({ emitEvent: false });
    }

    return fg;
  }

  /* ---------- RULES ENGINE (CRITICAL) ---------- */

  private applyRowRules(row: FormGroup): void {
    const categoryCtrl = row.get('fieldCategory')!;
    const requirementCtrl = row.get('fieldRequirement')!;
    const dependentCtrl = row.get('dependentField')!;
    const allowedCtrl = row.get('allowedValues')!;
    const standardCtrl = row.get('standardValues')!;

    // Field Requirement
    if (categoryCtrl.value === 'Derived') {
      requirementCtrl.clearValidators();
      requirementCtrl.setValue(null, { emitEvent: false });
      requirementCtrl.disable({ emitEvent: false });
    } else {
      requirementCtrl.setValidators(Validators.required);
      requirementCtrl.enable({ emitEvent: false });
    }
    requirementCtrl.updateValueAndValidity({ emitEvent: false });

    // Dependent Field
    if (requirementCtrl.value === 'Conditionally mandatory') {
      dependentCtrl.setValidators(Validators.required);
      dependentCtrl.enable({ emitEvent: false });
    } else {
      dependentCtrl.clearValidators();
      dependentCtrl.setValue(null, { emitEvent: false });
      dependentCtrl.disable({ emitEvent: false });
    }
    dependentCtrl.updateValueAndValidity({ emitEvent: false });

    // Standard Values
    if (allowedCtrl.value === 'STANDARD_VALUES') {
      standardCtrl.setValidators([
        Validators.required,
        this.standardValuesValidator(),
      ]);
      standardCtrl.enable({ emitEvent: false });
    } else {
      standardCtrl.clearValidators();
      standardCtrl.setValue(null, { emitEvent: false });
      standardCtrl.disable({ emitEvent: false });
    }
    standardCtrl.updateValueAndValidity({ emitEvent: false });
  }

  private wireRowSubscriptions(row: FormGroup): void {
    row.get('fieldCategory')!.valueChanges.subscribe(() =>
      this.applyRowRules(row)
    );
    row.get('fieldRequirement')!.valueChanges.subscribe(() =>
      this.applyRowRules(row)
    );
    row.get('allowedValues')!.valueChanges.subscribe(() =>
      this.applyRowRules(row)
    );
  }

  /* ---------- HELPERS ---------- */

  getDependentOptions(rowIndex: number): string[] {
    return this.rows.controls
      .map((row, idx) =>
        idx !== rowIndex ? row.get('uiFieldName')?.value : null
      )
      .filter((v) => !!v);
  }

  private standardValuesValidator() {
    return (control: AbstractControl) => {
      if (!control.value) return null;

      const values = control.value
        .split(',')
        .map((v: string) => v.trim())
        .filter(Boolean);

      if (values.length > 10) return { maxStandardValues: true };

      const invalid = values.some((v) => {
        if (/^\d+$/.test(v)) return false;
        if (/^".+"$/.test(v)) return false;
        return true;
      });

      return invalid ? { invalidStandardValue: true } : null;
    };
  }

  /* ---------- SAVE ---------- */

  save(): void {
    this.form.updateValueAndValidity({ emitEvent: false });

    if (this.form.invalid) {
      console.log('Save Failed');
      this.form.markAllAsTouched();
      return;
    }

    console.log('FINAL PAYLOAD', this.rows.getRawValue());
  }
}



//////////////



<form [formGroup]="form">
  <table
    mat-table
    [dataSource]="rows.controls"
    formArrayName="rows"
    class="mat-elevation-z1"
  >
    <ng-container *ngFor="let col of displayedColumns" [matColumnDef]="col">
      <th mat-header-cell *matHeaderCellDef>{{ col }}</th>

      <td
        mat-cell
        *matCellDef="let row; let i = index"
        [formGroupName]="i"
      >
        <!-- READ ONLY -->
        <ng-container
          *ngIf="['tableName','columnName','fieldDataType','fieldMaximumLength','numericPrecision','numericScale'].includes(col)"
        >
          {{ row.get(col)?.value }}
        </ng-container>

        <!-- INPUT -->
        <input
          *ngIf="['uiFieldName','defaultValue','standardValues','positionInTemplate'].includes(col)"
          matInput
          [formControlName]="col"
        />

        <!-- SELECTS -->
        <bmo-select-box
          *ngIf="col === 'formField'"
          [options]="formFieldOptions"
          formControlName="formField"
        ></bmo-select-box>

        <bmo-select-box
          *ngIf="col === 'fieldCategory'"
          [options]="fieldCategoryOptions"
          formControlName="fieldCategory"
        ></bmo-select-box>

        <bmo-select-box
          *ngIf="col === 'fieldRequirement'"
          [options]="fieldRequirementOptions"
          formControlName="fieldRequirement"
        ></bmo-select-box>

        <bmo-select-box
          *ngIf="col === 'dependentField'"
          [options]="getDependentOptions(i)"
          formControlName="dependentField"
        ></bmo-select-box>

        <bmo-select-box
          *ngIf="col === 'editableByUser'"
          [options]="yesNoOptions"
          formControlName="editableByUser"
        ></bmo-select-box>

        <bmo-select-box
          *ngIf="col === 'validationRuleExists'"
          [options]="yesNoOptions"
          formControlName="validationRuleExists"
        ></bmo-select-box>

        <bmo-select-box
          *ngIf="col === 'derivationRuleExists'"
          [options]="yesNoOptions"
          formControlName="derivationRuleExists"
        ></bmo-select-box>

        <bmo-select-box
          *ngIf="col === 'allowedValues'"
          [options]="allowedValuesOptions"
          formControlName="allowedValues"
        ></bmo-select-box>
      </td>
    </ng-container>

    <tr mat-header-row *matHeaderRowDef="displayedColumns; sticky: true"></tr>
    <tr mat-row *matRowDef="let row; columns: displayedColumns"></tr>
  </table>

  <button mat-raised-button color="primary" (click)="save()">Save</button>
</form>
