/****************************************************************************************
 * 1.  Utility — parse an escaped-newline CSV string into AG-Grid inputs
 ****************************************************************************************/
import { ColDef } from 'ag-grid-community';

/** Converts `uid,test_col_1,…\\n1,1.00,cat,ERRORS\\n…` ➜ `{colDefs,rowData}` */
export function csvToAgGrid(payload: string): { colDefs: ColDef[]; rowData: any[] } {
  // 1️⃣  normalise line breaks (`\n` is literally “backslash-n” in the payload)
  const normalised = payload.replace(/\\n/g, '\n').trim();

  // 2️⃣  split the header & rows
  const [headerLine, ...dataLines] = normalised.split('\n');
  const headers = headerLine.split(',');

  // 3️⃣  build column definitions on the fly
  const colDefs: ColDef[] = headers.map(h => ({
    headerName: toTitleCase(h),
    field: h,
    sortable: true,
    filter: true,
    resizable: true,
  }));

  // 4️⃣  build row data
  const rowData = dataLines
    .filter(l => l.trim().length)
    .map(line => {
      const values = line.split(',');
      return headers.reduce((obj, h, i) => {
        obj[h] = cast(values[i]);
        return obj;
      }, {} as any);
    });

  return { colDefs, rowData };

  /* ─── helpers ─────────────────────────────────────────────────────────────── */
  function toTitleCase(s: string): string {
    return s
      .replace(/_/g, ' ')
      .toLowerCase()
      .replace(/\b\w/g, c => c.toUpperCase());
  }
  function cast(v: string): string | number {
    const n = Number(v);
    return isNaN(n) ? v : n;
  }
}

























/****************************************************************************************
 * csvToGrid() – parses escaped-newline CSV ➜ { colDefs, rowData }
 * Mirrors width logic & cellClassRules from gridRendering().
 ****************************************************************************************/
import { ColDef } from 'ag-grid-community';

function csvToGrid(payload: string,
                   setRowStyle: (p: any, f: string) => any): { colDefs: ColDef[]; rowData: any[] } {

  /* ── 0.  prepare data ───────────────────────────────────────────────────────────── */
  const [headerLine, ...dataLines] =
    payload.replace(/\\n/g, '\n').trim().split('\n');      // de-escape "\n"
  const headers = headerLine.split(',');

  const rowData = dataLines
    .filter(Boolean)                                      // ignore blank lines
    .map(line => {
      const cells = line.split(',');
      return headers.reduce((obj, h, i) => {
        obj[h] = cast(cells[i]);                           // auto-cast numbers
        return obj;
      }, {} as any);
    });

  /* ── 1.  width calculation (same as your gridRendering) ─────────────────────────── */
  const staticColumnWidth = 75;
  const totalGridWidth    = window.innerWidth || 1200;

  const calWidths = headers.map(key => {
    const maxContentLen = Math.max(
      key.length,
      ...rowData.map(r => String(r[key]).length)
    );

    return {
      key,
      width: maxContentLen < 50      // identical rule you use now
        ? maxContentLen * 8 + 23
        : maxContentLen * 7,
    };
  });

  const totalCalWidth  = calWidths.reduce((sum, c) => sum + c.width, 0);
  const availableWidth = totalGridWidth - staticColumnWidth;

  const scaled = calWidths.map(c => ({
    ...c,
    width: Math.round((c.width / totalCalWidth) * availableWidth),
  }));

  /* ── 2.  build columnDefs with same style / rules ───────────────────────────────── */
  const colDefs: ColDef[] = [
    {                                             // S. No. column
      headerName  : 'S.no.',
      valueGetter : 'node.rowIndex + 1',
      width       : staticColumnWidth,
      pinned      : 'left',
      lockPinned  : true,
      headerClass : 'align-left',
    },
    ...scaled.map(col => ({
      headerName : col.key,
      field      : col.key,
      width      : col.width,
      editable   : false,
      cellStyle  : (p: any) => setRowStyle?.(p, col.key),
      cellClassRules: {
        'align-left'  : (p: any) => typeof p.value !== 'number',
        'align-right' : (p: any) => typeof p.value === 'number',
      },
    })),
  ];

  return { colDefs, rowData };

  /* ── helpers ────────────────────────────────────────────────────────────────────── */
  function cast(v: string): string | number {
    const n = Number(v);
    return isNaN(n) ? v : n;
  }
}




















































csvToGrid(payload: string): { colDefs: ColDef[]; rowData: any[] } {
  /* ── 0.  unescape and split lines ──────────────────────────────────────────── */
  const [headerLine, ...dataLines] =
    payload.replace(/\\n/g, '\n').trim().split('\n');

  const headers = headerLine.split(',');

  /* ── 1.  build rowData & cache max text length per column ──────────────────── */
  const maxLen: Record<string, number> = Object.fromEntries(
    headers.map(h => [h, h.length])
  );

  const rowData = dataLines
    .filter(Boolean)
    .map(line => {
      const cells = line.split(',');
      const row   = headers.reduce((obj, h, i) => {
        const value        = cast(cells[i]);
        maxLen[h]          = Math.max(maxLen[h], String(value).length);
        (obj as any)[h]    = value;
        return obj;
      }, {} as unknown as Record<string, any>);
      return row;
    });

  /* ── 2.  width calculation (identical to your component) ───────────────────── */
  const staticColumnWidth = 75;
  const totalGridWidth    = window.innerWidth || 1200;

  const calcWidths = headers.map(key => {
    const len = maxLen[key];
    const width =
      len < 50 ? len * 8 + 23 : len * 7;             // your rule
    return { key, width };
  });

  const totalCalcWidth  = calcWidths.reduce((s, c) => s + c.width, 0);
  const availableWidth  = totalGridWidth - staticColumnWidth;

  const scaled = calcWidths.map(c => ({
    key: c.key,
    width: Math.round((c.width / totalCalcWidth) * availableWidth),
  }));

  /* ── 3.  assemble columnDefs ───────────────────────────────────────────────── */
  const colDefs: ColDef[] = [
    {
      headerName : 'S.no.',
      valueGetter: 'node.rowIndex + 1',
      width      : staticColumnWidth,
      pinned     : 'left',
      lockPinned : true,
      headerClass: 'align-left',
    },
    ...scaled.map(c => ({
      headerName : c.key,
      field      : c.key,
      width      : c.width,
      editable   : false,
      cellClassRules: {
        'align-right': (p: any) => typeof p.value === 'number',
        'align-left' : (p: any) => typeof p.value !== 'number',
      },
    })),
  ];

  return { colDefs, rowData };

  /* ── helpers ───────────────────────────────────────────────────────────────── */
  function cast(v: string): string | number {
    const n = Number(v);
    return isNaN(n) ? v : n;
  }
}








// Updated code to fix issue

export function csvToGrid(payload: string): { colDefs: ColDef[]; rowData: any[] } {
  /* ── 1.  split CSV into header + rows ────────────────────────────────────── */
  const [headerLine, ...dataLines] =
    payload.replace(/\\n/g, '\n').trimEnd().split('\n');

  const headers = headerLine.split(',');

  /* ── 2.  first pass: collect raw rows & detect “numeric‑only” columns ────── */
  const numberRegex = /^-?\d+(?:\.\d+)?$/;
  const numericOnly: Record<string, boolean> = Object.fromEntries(
    headers.map(h => [h, true])
  );

  const rawRows = dataLines
    .filter(Boolean)
    .map(line => {
      const cells = line.split(',');
      headers.forEach((h, i) => {
        const v = cells[i]?.trim() ?? '';
        if (v !== '' && !numberRegex.test(v)) numericOnly[h] = false;
      });
      return cells;
    });

  /* ── 3.  second pass: build rowData & track max string length per column ── */
  const maxLen: Record<string, number> = Object.fromEntries(
    headers.map(h => [h, h.length])
  );

  const rowData = rawRows.map(cells => {
    const obj: Record<string, any> = {};
    headers.forEach((h, i) => {
      const raw = cells[i]?.trim() ?? '';
      let val: string | number = raw;               // default as string
      if (raw !== '' && numericOnly[h]) val = Number(raw);

      obj[h]  = val;
      maxLen[h] = Math.max(maxLen[h], String(val).length);
    });
    return obj;
  });

  /* ── 4.  calculate widths (same formula you use) ────────────────────────── */
  const staticWidth = 75;                     // S.no.
  const gridWidth   = window.innerWidth || 1200;

  const calcWidths = headers.map(k => {
    const len = maxLen[k];
    const w   = len < 50 ? len * 8 + 23 : len * 7;
    return { key: k, width: w };
  });

  const totalCalc = calcWidths.reduce((s, c) => s + c.width, 0);
  const availW    = gridWidth - staticWidth;

  const scaled = calcWidths.map(c => ({
    key  : c.key,
    width: Math.round((c.width / totalCalc) * availW),
  }));

  /* ── 5.  build columnDefs; move cfuf_status_cd after S.no. ───────────────── */
  const statusKey = 'cfuf_status_cd';

  const makeCol = (c: { key: string; width: number }): ColDef => ({
    headerName    : c.key === statusKey ? 'Status' : c.key,
    field         : c.key,
    width         : c.width,
    editable      : false,
    cellClassRules: {
      'align-right': (p: any) =>
        numericOnly[c.key] && p.value !== '',
      'align-left' : (p: any) =>
        !numericOnly[c.key] || p.value === '',
    },
  });

  const statusCol = scaled.filter(c => c.key === statusKey).map(makeCol)[0];
  const otherCols = scaled.filter(c => c.key !== statusKey).map(makeCol);

  const colDefs: ColDef[] = [
    {
      headerName : 'S.no.',
      valueGetter: 'node.rowIndex + 1',
      width      : staticWidth,
      pinned     : 'left',
      lockPinned : true,
      headerClass: 'align-left',
    },
    statusCol,        // second position
    ...otherCols,
  ];

  return { colDefs, rowData };
}






//// update to column widths 


/******************************************************************************
 * csvToGrid()  – escaped‑newline CSV ➜ { colDefs, rowData }
 *   • Keeps empty cells blank (no “0”).
 *   • Treats a column as numeric only if *every* non‑empty value is a number.
 *   • Sizes each column directly from content length (no scaling).
 *   • cfuf_status_cd ➜ header “Status” and appears after S.no.
 *
 * Remove the ColDef import if you don’t want type checking.
 ******************************************************************************/
import type { ColDef } from 'ag-grid-community'; // ← optional

export function csvToGrid(payload: string): { colDefs: ColDef[]; rowData: any[] } {
  /* ── 1.  header & data lines ─────────────────────────────────────────────── */
  const [headerLine, ...dataLines] =
    payload.replace(/\\n/g, '\n').trimEnd().split('\n');

  const headers = headerLine.split(',');

  /* ── 2.  detect numeric‑only columns & keep raw rows ─────────────────────── */
  const numericOnly: Record<string, boolean> = Object.fromEntries(
    headers.map(h => [h, true]),
  );
  const numberRE = /^-?\d+(?:\.\d+)?$/;

  const rawRows = dataLines
    .filter(Boolean)
    .map(line => {
      const cells = line.split(',');
      headers.forEach((h, i) => {
        const v = (cells[i] ?? '').trim();
        if (v !== '' && !numberRE.test(v)) numericOnly[h] = false;
      });
      return cells;
    });

  /* ── 3.  build rowData & record max string length for each column ────────── */
  const maxLen: Record<string, number> = Object.fromEntries(
    headers.map(h => [h, h.length]),
  );

  const rowData = rawRows.map(cells => {
    const obj: Record<string, any> = {};
    headers.forEach((h, i) => {
      const raw = (cells[i] ?? '').trim();
      const val =
        raw === ''               ? '' :
        numericOnly[h]           ? Number(raw) :
                                   raw;               // keep as string
      obj[h] = val;
      maxLen[h] = Math.max(maxLen[h], String(val).length);
    });
    return obj;
  });

  /* ── 4.  column width = f(content length); no scaling ────────────────────── */
  const widthInfo = headers.map(key => {
    const len = maxLen[key];
    const width = len < 50 ? len * 8 + 23 : len * 7;   // your original rule
    return { key, width };
  });

  /* ── 5.  produce columnDefs, moving cfuf_status_cd after S.no. ───────────── */
  const statusKey = 'cfuf_status_cd';

  const makeCol = ({ key, width }: { key: string; width: number }): ColDef => ({
    headerName    : key === statusKey ? 'Status' : key,
    field         : key,
    width,
    editable      : false,
    cellClassRules: {
      'align-right': (p: any) => numericOnly[key] && p.value !== '',
      'align-left' : (p: any) => !numericOnly[key] || p.value === '',
    },
  });

  const statusCol  = widthInfo.filter(w => w.key === statusKey).map(makeCol)[0];
  const otherCols  = widthInfo.filter(w => w.key !== statusKey).map(makeCol);

  const colDefs: ColDef[] = [
    {
      headerName : 'S.no.',
      valueGetter: 'node.rowIndex + 1',
      width      : 75,
      pinned     : 'left',
      lockPinned : true,
      headerClass: 'align-left',
    },
    statusCol,      // second position
    ...otherCols,
  ];

  return { colDefs, rowData };
}



 ///
//// update 3




 /* ── 1.  split header / rows ─────────────────────────────────────────────── */
  const [headerLine, ...dataLines] =
    payload.replace(/\\n/g, '\n').trimEnd().split('\n');

  const headers = headerLine.split(',');

  /* ── 2.  discover numeric‑only columns & store raw rows ──────────────────── */
  const numericOnly: Record<string, boolean> = Object.fromEntries(
    headers.map(h => [h, true]),
  );
  const numRE = /^-?\d+(?:\.\d+)?$/;            // simple “is number” regex

  const rawRows = dataLines
    .filter(Boolean)
    .map(line => {
      const cells = line.split(',');
      headers.forEach((h, i) => {
        const v = (cells[i] ?? '').trim();
        if (v !== '' && !numRE.test(v)) numericOnly[h] = false;
      });
      return cells;
    });

  /* ── 3.  second pass: build rowData & maxLen per column ──────────────────── */
  const maxLen: Record<string, number> = Object.fromEntries(
    headers.map(h => [h, h.length]),            // start with header length
  );

  const rowData = rawRows.map(cells => {
    const row: Record<string, any> = {};
    headers.forEach((h, i) => {
      const raw = (cells[i] ?? '').trim();
      const val =
        raw === ''                ? '' :
        numericOnly[h]            ? Number(raw) :
                                    raw;

      row[h]  = val;
      maxLen[h] = Math.max(maxLen[h], String(val).length);
    });
    return row;
  });

  /* ── 4.  width = maxLen * charPx + padding ───────────────────────────────── */
  const charPx  = 7;      // average character width
  const padding = 16;     // cell padding so text isn't flush to border

  const widthInfo = headers.map(k => ({
    key  : k,
    width: maxLen[k] * charPx + padding,
  }));

  /* ── 5.  build columnDefs, moving Status after S.no. ─────────────────────── */
  const statusKey = 'cfuf_status_cd';

  const makeCol = ({ key, width }: { key: string; width: number }): ColDef => ({
    headerName    : key === statusKey ? 'Status' : key,
    field         : key,
    width,
    editable      : false,
    cellClassRules: {
      'align-right': (p: any) => numericOnly[key] && p.value !== '',
      'align-left' : (p: any) => !numericOnly[key] || p.value === '',
    },
  });

  const statusCol  = widthInfo.filter(w => w.key === statusKey).map(makeCol)[0];
  const otherCols  = widthInfo.filter(w => w.key !== statusKey).map(makeCol);

  const colDefs: ColDef[] = [
    {
      headerName : 'S.no.',
      valueGetter: 'node.rowIndex + 1',
      width      : 75,
      pinned     : 'left',
      lockPinned : true,
      headerClass: 'align-left',
    },
    statusCol,
    ...otherCols,
  ];

  return { colDefs, rowData };
