// Types you can tweak to your real API
export interface SystemHealthRec {
  sh_uid: string;
  sh_report_date: string;      // e.g. "2025-07-31"
  last_updated_ts?: string;    // e.g. "2025-09-26T17:53:08.083Z"
  // ...anything else from the API
}

export interface ApiResponse {
  statusCode: number;
  success: boolean;
  message: string;
  data: SystemHealthRec[];
}

/**
 * Pick the latest (by last_updated_ts) record per sh_report_date.
 * - Ignores items with missing/invalid last_updated_ts unless it's the only one for that date.
 * - Returns an array, optionally sorted by sh_report_date (desc by default).
 */
export function pickLatestByReportDate(
  rows: SystemHealthRec[],
  sortDesc: boolean = true
): SystemHealthRec[] {
  const byDate: Record<string, SystemHealthRec> = {};

  for (const rec of rows) {
    const key = rec.sh_report_date?.trim();
    if (!key) continue;

    const candidateTime = Date.parse(rec.last_updated_ts ?? "");
    const hasCandidateTime = !Number.isNaN(candidateTime);

    const existing = byDate[key];
    if (!existing) {
      // first record for the date — store it even if timestamp is missing
      byDate[key] = rec;
      continue;
    }

    const existingTime = Date.parse(existing.last_updated_ts ?? "");
    const hasExistingTime = !Number.isNaN(existingTime);

    // Choose the one with a valid and greater timestamp.
    // If only one has a valid timestamp, prefer that one.
    // If both invalid, keep the existing (first seen).
    if (hasCandidateTime && (!hasExistingTime || candidateTime > existingTime)) {
      byDate[key] = rec;
    }
  }

  const result = Object.values(byDate);

  // optional sort: newest report date first
  result.sort((a, b) =>
    sortDesc
      ? a.sh_report_date < b.sh_report_date ? 1 : a.sh_report_date > b.sh_report_date ? -1 : 0
      : a.sh_report_date > b.sh_report_date ? 1 : a.sh_report_date < b.sh_report_date ? -1 : 0
  );

  return result;
}














export function pickLatestByReportDate(rows: SystemHealthRec[]): SystemHealthRec[] {
  const byDate: Record<string, SystemHealthRec> = {};

  for (const rec of rows) {
    const key = rec.sh_report_date?.trim();
    if (!key) continue;

    const candidateTime = Date.parse(rec.last_updated_ts ?? "");
    const hasCandidateTime = !Number.isNaN(candidateTime);

    if (!byDate[key]) {
      // first record → keep it
      byDate[key] = rec;
    } else {
      const existing = byDate[key];
      const existingTime = Date.parse(existing.last_updated_ts ?? "");
      const hasExistingTime = !Number.isNaN(existingTime);

      if (
        hasCandidateTime &&
        (!hasExistingTime || candidateTime > existingTime)
      ) {
        byDate[key] = rec;
      }
    }
  }

  return Object.values(byDate);





























type SHRow = {
  sh_report_date: string;          // e.g. "2025-07-31"
  last_updated_ts?: string | null; // e.g. "2025-09-26T17:53:08.083Z"
  // ...other fields
};

/**
 * Returns one latest row per unique sh_report_date.
 * - Compares only within the same sh_report_date.
 * - If last_updated_ts is invalid/missing, treats it as the smallest value.
 * - If timestamps tie, keeps the first seen (stable).
 */
export function latestPerReportDate(rows: SHRow[]): SHRow[] {
  const byDate = new Map<string, SHRow>();

  for (const rec of rows) {
    const key = (rec.sh_report_date ?? "").trim();
    if (!key) continue;

    const candidateTime = Date.parse(rec.last_updated_ts ?? "");
    const candScore = Number.isNaN(candidateTime) ? -Infinity : candidateTime;

    const existing = byDate.get(key);
    if (!existing) {
      byDate.set(key, rec);
      continue;
    }

    const existingTime = Date.parse(existing.last_updated_ts ?? "");
    const existScore = Number.isNaN(existingTime) ? -Infinity : existingTime;

    if (candScore > existScore) {
      byDate.set(key, rec);
    }
    // else if candScore === existScore: tie -> keep existing (stable)
  }

  // Optional: sort by report date desc so UI can bind directly.
  return Array.from(byDate.values()).sort((a, b) =>
    (b.sh_report_date ?? "").localeCompare(a.sh_report_date ?? "")
  );
}
