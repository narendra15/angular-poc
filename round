function formatValue(value: string | number, dataType: 'decimal' | 'integer'): string {
  if (dataType === 'decimal') {
    const num = Number(value);
    if (isNaN(num)) return String(value); // in case it's not a valid number
    return num.toFixed(3);
  } else if (dataType === 'integer') {
    // Remove leading zeros but keep '0' if value is 0 or all zeros
    return String(Number(value));
  }
  return String(value);
}




const upDatedBody = lines.slice(1).map((line: string) => {
  // âœ… Split correctly even when commas are inside quotes
  const cols = line.match(/(".*?"|[^",]+)(?=\s*,|\s*$)/g) || [];

  const formattedCols = cols.map((val) => {
    // Remove wrapping quotes temporarily for detection
    const cleanVal = val.replace(/^"|"$/g, '');

    if (cleanVal.includes('.') && !isNaN(Number(cleanVal))) {
      return this.formatValue(cleanVal, 'decimal');
    } else if (!isNaN(Number(cleanVal))) {
      return this.formatValue(cleanVal, 'integer');
    }

    // Keep quotes if originally quoted
    return val;
  });

  return formattedCols.join(',');
});








////------------////









private formatCsvValue(value: string, dataType: string): string {
  // keep empty as-is
  if (value === '') return value;

  if (dataType === 'decimal') {
    const num = Number(value);
    if (!isNaN(num)) return num.toFixed(3);
    return value;
  }

  if (dataType === 'integer') {
    // trim leading zeros, preserve negative and + sign if any
    const match = value.match(/^([+-]?)(\d+)$/);
    if (!match) return value;
    const sign = match[1];
    const digits = match[2].replace(/^0+(?=\d)/, '');
    return `${sign}${digits}`;
  }

  // keep all other types as-is
  return value;
}

// CSV-safe splitter (handles commas inside quotes, keeps empty)
private parseCsvLine(line: string): string[] {
  const result: string[] = [];
  let current = '';
  let insideQuotes = false;

  for (let i = 0; i < line.length; i++) {
    const char = line[i];
    if (char === '"') {
      if (insideQuotes && line[i + 1] === '"') {
        current += '"';
        i++; // skip next quote
      } else {
        insideQuotes = !insideQuotes;
      }
    } else if (char === ',' && !insideQuotes) {
      result.push(current);
      current = '';
    } else {
      current += char;
    }
  }
  result.push(current);
  return result;
}

// escape CSV safely
private escapeCsv(val: string): string {
  if (val.includes(',') || val.includes('"') || val.includes('\n')) {
    return `"${val.replace(/"/g, '""')}"`;
  }
  return val;
}




// integrate in your download logic
const upDatedBody = lines.slice(1).map((line: string) => {
  const cols = this.parseCsvLine(line);

  const formattedCols = cols.map((val, idx) => {
    const type = this.dataType[idx]?.dataType?.toLowerCase() || 'string';
    return this.formatCsvValue(val, type);
  });

  // rejoin preserving empties and quotes
  return formattedCols.map(this.escapeCsv).join(',');
});




































// Parse one CSV line (handles quotes, commas-in-quotes, and "" escapes)
function parseCsvLine(line: string): (string | null)[] {
  const out: string[] = [];
  let cur = '';
  let inQuotes = false;

  for (let i = 0; i < line.length; i++) {
    const ch = line[i];

    if (ch === '"') {
      // Handle escaped quote ("")
      if (inQuotes && line[i + 1] === '"') {
        cur += '"';
        i++;
      } else {
        inQuotes = !inQuotes;
      }
    } else if (ch === ',' && !inQuotes) {
      out.push(cur);
      cur = '';
    } else {
      cur += ch;
    }
  }
  out.push(cur);

  // Keep truly empty columns as null (so index 0 can be null)
  return out.map(v => (v === '' ? null : v));
}

// Convert the "lines dataSnap" array into the numeric-keyed row objects
function toExcelRows(linesDataSnap: string[]): Array<Record<number, string | null>> {
  return linesDataSnap.map(line => {
    const cols = parseCsvLine(line);
    const rowObj: Record<number, string | null> = {};
    for (let i = 0; i < cols.length; i++) {
      rowObj[i] = cols[i]; // keys: 0,1,2,... matching your screenshot
    }
    return rowObj;
  });
}

// Usage:
this.excelRows = toExcelRows(linesDataSnap);
