src/app/system-health/models.ts



// Types that match your existing JSON one-to-one and are easy to use in templates.

export type IsoDate = `${number}-${number}-${number}`; // "YYYY-MM-DD"
export type ShStatus = 'S' | 'W' | 'E';

export interface ShRaw {
  sh_report_date: string;            // e.g. "2025-06-01"
  sh_file_display_ctgry: string;     // e.g. "QRM", "QRM Monthly", "AXIOM", "Mapping File 1"
  sh_file_ctgry: 'S' | 'A' | 'M' | 'L';
  Sh_active_rec_ind: 'A' | 'I';
  sh_feed_load_date?: string;
  sh_status?: ShStatus;
  sh_record_source_cnt?: number;
  sh_record_target_cnt?: number;
}

export interface DayMeta {
  date: IsoDate;
  isWeekend: boolean;
  isFuture: boolean;
  isPastOrToday: boolean;
}

export type CellKind =
  | 'Success'       // green dot
  | 'Warning'       // amber dot
  | 'Error'         // red dot
  | 'NotReceived'   // red ring (no record for Source)
  | 'NotGenerated'  // red dot (AXIOM missing on past/today)
  | 'Blank';        // weekend/future placeholder

export interface TooltipData {
  title: string;
  fields: Array<{ label: string; value: string | number }>;
  actions?: Array<{ label: string; action: string }>; // string for simplicity
}

export interface Cell {
  date: IsoDate;
  kind: CellKind;
  shStatus?: ShStatus;
  tooltip?: TooltipData;
  colSpan?: number; // used only for "Monthly" rows
}

export interface Row {
  id: string;
  label: string;
  cells: Cell[];
}

export interface MappingColumn {
  id: string;
  label: string;
  status: CellKind;
  shStatus?: ShStatus;
  tooltip?: TooltipData;
}









///////////////////////////////
2) src/app/system-health/ingest.ts



// Converts your existing dummyData.json array (ShRaw[]) into UI-ready rows/columns.
// Very small, commented, and beginner-friendly.

import { Cell, CellKind, DayMeta, MappingColumn, Row, ShRaw, ShStatus } from './models';

/* ------------------------------------------------
 * Small helpers
 * ----------------------------------------------*/
function toCellKind(status?: ShStatus): CellKind {
  if (status === 'S') return 'Success';
  if (status === 'W') return 'Warning';
  if (status === 'E') return 'Error';
  return 'Blank';
}
function key(label: string, isoDate: string) { return `${label}__${isoDate}`; }

/** Keep the latest Active record for each (label, date) pair. */
function latestActive(records: ShRaw[]) {
  const map = new Map<string, ShRaw>();
  for (const r of records) {
    if (r.Sh_active_rec_ind !== 'A') continue;
    const k = key(r.sh_file_display_ctgry, r.sh_report_date);
    const prev = map.get(k);
    if (!prev) { map.set(k, r); continue; }
    const tPrev = new Date(prev.sh_feed_load_date || prev.sh_report_date).getTime();
    const tCurr = new Date(r.sh_feed_load_date || r.sh_report_date).getTime();
    if (tCurr >= tPrev) map.set(k, r);
  }
  return map;
}

/* ------------------------------------------------
 * Simple tooltip builders
 * ----------------------------------------------*/
function tooltipSource(rec: ShRaw) {
  const base = [
    { label: 'Loaded on', value: rec.sh_feed_load_date || 'NA' },
    { label: 'Records Loaded', value: `${rec.sh_record_source_cnt ?? 0}/${rec.sh_record_target_cnt ?? 0}` }
  ];
  const title =
    rec.sh_status === 'W' ? 'Loaded with Warnings' :
    rec.sh_status === 'E' ? 'Load Failed' :
    'Loaded Successfully';
  return { title, fields: base };
}
function tooltipAxiomOK(rec: ShRaw) {
  return {
    title: 'File Generated',
    fields: [
      { label: 'Last generated on', value: rec.sh_feed_load_date || 'NA' },
      { label: 'Records Loaded', value: rec.sh_record_target_cnt ?? 0 }
    ]
  };
}
function tooltipAxiomMissing() {
  return {
    title: 'Not Generated',
    fields: [
      { label: 'Last Generated on', value: 'NA' },
      { label: 'Records Loaded', value: 0 }
    ]
  };
}
function tooltipMapping(rec: ShRaw) {
  const title =
    rec.sh_status === 'W' ? 'Submitted with Warnings' :
    rec.sh_status === 'E' ? 'Submitted with Errors' :
    'Approved and Merged';
  return {
    title,
    fields: [
      { label: 'File Date', value: rec.sh_feed_load_date || 'NA' },
      { label: 'Records', value: rec.sh_record_target_cnt ?? 0 }
    ],
    actions: [{ label: 'Validation Checks', action: 'validation-checks' }]
  };
}

/* ------------------------------------------------
 * Row/Column builders used by your store/page
 * ----------------------------------------------*/

/** Build rows for Source Systems (cat='S') or AXIOM (cat='A'). */
export function buildGridRows(all: ShRaw[], days: DayMeta[], cat: 'S' | 'A'): Row[] {
  const pool = all.filter(r => r.sh_file_ctgry === cat && r.Sh_active_rec_ind === 'A');
  const byKey = latestActive(pool);
  const labels = Array.from(new Set(pool.map(r => r.sh_file_display_ctgry))).sort();

  return labels.map(label => {
    const isMonthly = label.toLowerCase().includes('monthly');

    // Monthly rows → ONE big cell spanning all days
    if (isMonthly) {
      const anyRecord = Array.from(byKey.values()).find(r => r.sh_file_display_ctgry === label);
      const kind: CellKind = anyRecord
        ? toCellKind(anyRecord.sh_status)
        : (cat === 'S' ? 'NotReceived' : 'NotGenerated');
      return {
        id: `${cat}-${label}`.toLowerCase().replace(/\s+/g, '-'),
        label,
        cells: [{
          date: days[0].date,
          kind,
          shStatus: anyRecord?.sh_status,
          tooltip: anyRecord
            ? (cat === 'S' ? tooltipSource(anyRecord) : tooltipAxiomOK(anyRecord))
            : (cat === 'S' ? undefined : tooltipAxiomMissing()),
          colSpan: days.length
        }]
      };
    }

    // Daily rows → one cell per day
    const cells: Cell[] = days.map(d => {
      const rec = byKey.get(key(label, d.date));
      if (rec) {
        return {
          date: d.date,
          kind: toCellKind(rec.sh_status),
          shStatus: rec.sh_status,
          tooltip: cat === 'S' ? tooltipSource(rec) : tooltipAxiomOK(rec)
        };
      }
      // No record:
      if (cat === 'S') {
        // For past/today weekdays show "NotReceived" ring; otherwise leave blank.
        if (d.isPastOrToday && !d.isWeekend) return { date: d.date, kind: 'NotReceived' };
        return { date: d.date, kind: 'Blank' };
      } else {
        // For AXIOM show "NotGenerated" on past/today, else blank.
        return d.isPastOrToday
          ? { date: d.date, kind: 'NotGenerated', tooltip: tooltipAxiomMissing() }
          : { date: d.date, kind: 'Blank' };
      }
    });

    return { id: `${cat}-${label}`.toLowerCase().replace(/\s+/g, '-'), label, cells };
  });
}

/** Build columns for Mapping Files (monthly snapshot). */
export function buildMappingColumns(all: ShRaw[]): MappingColumn[] {
  const pool = all.filter(r => (r.sh_file_ctgry === 'M' || r.sh_file_ctgry === 'L') && r.Sh_active_rec_ind === 'A');
  const labels = Array.from(new Set(pool.map(r => r.sh_file_display_ctgry))).sort();

  return labels.map(label => {
    const rec = pool
      .filter(r => r.sh_file_display_ctgry === label)
      .sort((a, b) =>
        new Date(b.sh_feed_load_date || b.sh_report_date).getTime() -
        new Date(a.sh_feed_load_date || a.sh_report_date).getTime()
      )[0];

    return {
      id: label.toLowerCase().replace(/\s+/g, '-'),
      label,
      status: toCellKind(rec?.sh_status),
      shStatus: rec?.sh_status,
      tooltip: rec ? tooltipMapping(rec) : undefined
    };
  });
}







///////////////////////

3) src/app/system-health/components/status-indicator.component.ts



import { Component, Input } from '@angular/core';

@Component({
  standalone: true,
  selector: 'app-status-indicator',
  styles: [`
    :host { display:inline-block; line-height:0; }
    .dot  { width:12px; height:12px; border-radius:9999px; display:inline-block; }
    .ring { width:12px; height:12px; border-radius:9999px; border:2px solid #ef4444; }
    .green { background:#22c55e; }
    .amber { background:#f59e0b; }
    .red   { background:#ef4444; }
  `],
  template: `<span [ngClass]="classes()"></span>`
})
export class StatusIndicatorComponent {
  @Input() variant: 'green'|'amber'|'red'|'ring' = 'green';
  classes() { return this.variant === 'ring' ? 'ring' : `dot ${this.variant}`; }
}






//////////////////////////////
4) src/app/system-health/components/tooltip-card.component.ts



import { Component, EventEmitter, Input, Output } from '@angular/core';
import { NgIf, NgFor } from '@angular/common';
import { TooltipData } from '../models';

@Component({
  standalone: true,
  selector: 'app-tooltip-card',
  imports: [NgIf, NgFor],
  styles: [`
    .tip { position:absolute; background:#fff; border:1px solid #e5e7eb; border-radius:8px;
           box-shadow:0 10px 24px rgba(0,0,0,.12); min-width:220px; z-index:100; }
    .hdr { display:flex; align-items:center; justify-content:space-between; gap:8px;
           padding:8px 10px; border-bottom:1px solid #f1f5f9; font-weight:600; }
    .body{ padding:8px 10px; }
    .kv  { display:flex; justify-content:space-between; gap:10px; font-size:12px; padding:2px 0; }
    .act { padding:8px 10px; display:flex; gap:8px; border-top:1px solid #f1f5f9; }
    button.close { border:none; background:transparent; font-size:16px; line-height:1; cursor:pointer; }
    button.action{ font-size:12px; padding:4px 8px; border:1px solid #e5e7eb; border-radius:6px; background:#f8fafc; cursor:pointer; }
  `],
  template: `
    <div *ngIf="open" class="tip" [style.left.px]="x" [style.top.px]="y">
      <div class="hdr">
        <span>{{ data?.title }}</span>
        <button class="close" aria-label="Close tooltip" (click)="close.emit()">×</button>
      </div>

      <div class="body">
        <div *ngFor="let f of data?.fields" class="kv">
          <span>{{ f.label }}</span>
          <span>{{ f.value }}</span>
        </div>
      </div>

      <div *ngIf="data?.actions as actions" class="act">
        <button class="action" *ngFor="let a of actions; let i = index"
                type="button" (click)="action.emit(a.action)">
          {{ a.label }}
        </button>
      </div>
    </div>
  `
})
export class TooltipCardComponent {
  @Input() open = false;
  @Input() data: TooltipData | null = null;
  @Input() x = 0;
  @Input() y = 0;

  @Output() close = new EventEmitter<void>();
  @Output() action = new EventEmitter<string>();
}





////////////////////////////
5) src/app/system-health/components/timeline-grid.component.ts






import { Component, EventEmitter, Input, Output } from '@angular/core';
import { NgFor, NgIf, NgSwitch, NgSwitchCase } from '@angular/common';
import { Cell, DayMeta, TooltipData } from '../models';
import { StatusIndicatorComponent } from './status-indicator.component';
import { TooltipCardComponent } from './tooltip-card.component';

@Component({
  standalone: true,
  selector: 'app-timeline-grid',
  imports: [NgFor, NgIf, NgSwitch, NgSwitchCase, StatusIndicatorComponent, TooltipCardComponent],
  styles: [`
    .wrap { overflow:auto; border:1px solid #e5e7eb; border-radius:8px; }
    .row { display:grid; grid-auto-flow:column; grid-auto-columns: var(--col-w, 42px); align-items:center; }
    .stick { position:sticky; left:0; background:white; z-index:1; padding:8px 12px; border-right:1px solid #f1f5f9; font-weight:600; }
    .cell { display:grid; place-items:center; height:34px; border-left:1px solid #f8fafc; }
    .hdr  { color:#475569; border-bottom:1px solid #eef2f7; }
    .hdr-stick { position:sticky; left:0; background:white; z-index:2; padding:8px 12px; border-right:1px solid #f1f5f9; }
    .hdr-cell { height: var(--hdr-h, 78px); display:grid; place-items:end center; padding-bottom:6px; border-left:1px solid #f8fafc; }
    .rot { transform-origin: bottom center; white-space:nowrap; font-size:12px; transform: rotate(var(--hdr-angle, -60deg)); }
    .monthly { background:#f9fafb; border-left:1px solid #eef2f7; border-right:1px solid #eef2f7; }
    .wknd { background:#f8fafc; }
  `],
  template: `
    <div class="wrap" [style.--col-w.px]="dayColumnWidth" [style.--hdr-h.px]="headerRowHeight" [style.--hdr-angle]="headerAngle">

      <!-- Optional header row with rotated dates -->
      <div *ngIf="showHeader" class="row hdr">
        <div class="hdr-stick">{{ headerTitle }}</div>
        <div *ngFor="let h of headers; let i=index" class="hdr-cell" [title]="fullHeaderTitles?.[i] || h">
          <span class="rot" *ngIf="rotateHeaders; else plain">{{ h }}</span>
          <ng-template #plain>{{ h }}</ng-template>
        </div>
      </div>

      <!-- Data rows -->
      <div *ngFor="let r of rows" class="row">
        <div class="stick">{{ r.label }}</div>

        <!-- Monthly row: single merged cell -->
        <ng-container *ngIf="isMonthly(r); else dailyRow">
          <div class="cell monthly"
               [style.gridColumn]="gridSpanForMonthly"
               (click)="openTip($event, r.cells[0])">
            <ng-container [ngSwitch]="r.cells[0].kind">
              <app-status-indicator *ngSwitchCase="'Success'" variant="green"></app-status-indicator>
              <app-status-indicator *ngSwitchCase="'Warning'" variant="amber"></app-status-indicator>
              <app-status-indicator *ngSwitchCase="'Error'"   variant="red"></app-status-indicator>
              <app-status-indicator *ngSwitchCase="'NotReceived'" variant="ring"></app-status-indicator>
              <app-status-indicator *ngSwitchCase="'NotGenerated'" variant="red"></app-status-indicator>
            </ng-container>
          </div>
        </ng-container>

        <!-- Daily row: one cell per day -->
        <ng-template #dailyRow>
          <div *ngFor="let c of r.cells; let i=index"
               class="cell"
               [class.wknd]="dayMeta[i]?.isWeekend && c.kind==='Blank'"
               (click)="openTip($event, c)">
            <ng-container [ngSwitch]="c.kind">
              <app-status-indicator *ngSwitchCase="'Success'" variant="green"></app-status-indicator>
              <app-status-indicator *ngSwitchCase="'Warning'" variant="amber"></app-status-indicator>
              <app-status-indicator *ngSwitchCase="'Error'"   variant="red"></app-status-indicator>
              <app-status-indicator *ngSwitchCase="'NotReceived'" variant="ring"></app-status-indicator>
              <app-status-indicator *ngSwitchCase="'NotGenerated'" variant="red"></app-status-indicator>
              <!-- Blank: render nothing -->
            </ng-container>
          </div>
        </ng-template>
      </div>
    </div>

    <!-- Tooltip -->
    <app-tooltip-card
      [open]="tipOpen"
      [data]="tipData"
      [x]="tipXY.x"
      [y]="tipXY.y"
      (close)="tipOpen=false"
      (action)="nav.emit($event)"
    />
  `
})
export class TimelineGridComponent {
  // Header controls
  @Input() showHeader = true;
  @Input() headerTitle = '';
  @Input() headers: string[] = [];
  @Input() fullHeaderTitles?: string[];
  @Input() rotateHeaders = true;
  @Input() headerAngle: string = '-60deg';
  @Input() headerRowHeight = 78;

  // Data
  @Input() dayMeta: DayMeta[] = [];
  @Input() rows: Array<{ label: string; cells: (Cell & { colSpan?: number })[] }> = [];

  // Layout
  @Input() dayColumnWidth = 42;

  @Output() nav = new EventEmitter<string>();

  tipOpen = false;
  tipData: TooltipData | null = null;
  tipXY = { x: 0, y: 0 };

  isMonthly(r: { cells: (Cell & { colSpan?: number })[] }) {
    return r.cells.length === 1 && !!r.cells[0].colSpan && r.cells[0].colSpan! > 1;
  }
  get gridSpanForMonthly() { return `2 / span ${this.headers.length}`; }

  openTip(ev: MouseEvent, cell?: Cell) {
    if (!cell?.tooltip) return;
    const rect = (ev.currentTarget as HTMLElement).getBoundingClientRect();
    this.tipXY = { x: rect.left + rect.width + 8 + window.scrollX, y: rect.top + window.scrollY };
    this.tipOpen = true;
    this.tipData = cell.tooltip!;
  }
}










/////////////////////////
6) src/app/system-health/store.ts




import { Injectable, signal, computed } from '@angular/core';
import { DayMeta, Row, MappingColumn, ShRaw, IsoDate } from './models';
import { buildGridRows, buildMappingColumns } from './ingest';
// NOTE: tweak the path to your assets folder as needed:
import dummyData from '../../../assets/dummyData.json';

/**
 * Build DayMeta for the given (year, month).
 * month is 1..12 (e.g., 6 = June).
 */
function buildDayMeta(year: number, month: number): DayMeta[] {
  const daysInMonth = new Date(year, month, 0).getDate();       // month is 1..12
  const today = new Date();

  const toIso = (y: number, m: number, d: number): IsoDate => {
    const mm = String(m).padStart(2, '0');
    const dd = String(d).padStart(2, '0');
    return `${y}-${mm}-${dd}` as IsoDate;
  };

  return Array.from({ length: daysInMonth }, (_, i) => {
    const day = i + 1;
    const date = new Date(year, month - 1, day);
    const iso = toIso(year, month, day);
    return {
      date: iso,
      isWeekend: date.getDay() === 0 || date.getDay() === 6,
      isFuture: date > today,
      isPastOrToday: date <= today
    };
  });
}

@Injectable({ providedIn: 'root' })
export class Store {
  /**
   * IMPORTANT: your dummyData.json in the screenshot is **June 2025**.
   * Set month=6 and year=2025 so headers align with the data.
   */
  month = signal<number>(6);     // 6 = June
  year  = signal<number>(2025);

  // raw calendar + processed rows/columns
  dayMeta = signal<DayMeta[]>([]);
  sourceRows = signal<Row[]>([]);
  axiomRows  = signal<Row[]>([]);
  mappingCols = signal<MappingColumn[]>([]);

  constructor() { this.load(); }

  /** "01, Sun" style header labels */
  headers = computed(() => {
    const dows = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
    return this.dayMeta().map(dm => {
      const d = new Date(dm.date);
      return `${dm.date.slice(-2)}, ${dows[d.getDay()]}`;
    });
  });

  /** Full ISO dates for header tooltips */
  fullHeaderTitles = computed(() => this.dayMeta().map(d => d.date));

  /** Build everything from the JSON + selected month */
  load() {
    const meta = buildDayMeta(this.year(), this.month());
    this.dayMeta.set(meta);

    const raw = dummyData as ShRaw[];  // your existing JSON array

    // Build rows per widget
    this.sourceRows.set(buildGridRows(raw, meta, 'S'));
    this.axiomRows.set(buildGridRows(raw, meta, 'A'));
    this.mappingCols.set(buildMappingColumns(raw));
  }

  // ---- simple getters so templates don't need to call .() on signals ----
  get headersValue()         { return this.headers(); }
  get fullHeaderTitlesValue(){ return this.fullHeaderTitles(); }
  get dayMetaValue()         { return this.dayMeta(); }
  get sourceRowsValue()      { return this.sourceRows(); }
  get axiomRowsValue()       { return this.axiomRows(); }
  get mappingColsValue()     { return this.mappingCols(); }
}





///////////////////////////////////

7) src/app/system-health/widgets/axiom.widget.ts





import { Component, inject } from '@angular/core';
import { TimelineGridComponent } from '../components/timeline-grid.component';
import { Store } from '../store';

@Component({
  standalone: true,
  selector: 'app-axiom-widget',
  imports: [TimelineGridComponent],
  template: `
    <app-timeline-grid
      headerTitle="File Generation for AXIOM Status"
      [showHeader]="true"
      [headers]="store.headersValue"
      [fullHeaderTitles]="store.fullHeaderTitlesValue"
      [dayMeta]="store.dayMetaValue"
      [rows]="store.axiomRowsValue"
      (nav)="onNav($event)"
    />
  `
})
export class AxiomWidget {
  store = inject(Store);
  onNav(action: string) {
    // Hook up real navigation here if you have a route or modal
    console.log('AXIOM action:', action);
  }
}




//////////////////////////////

8) src/app/system-health/widgets/source-systems.widget.ts




import { Component, inject } from '@angular/core';
import { TimelineGridComponent } from '../components/timeline-grid.component';
import { Store } from '../store';

@Component({
  standalone: true,
  selector: 'app-source-systems-widget',
  imports: [TimelineGridComponent],
  template: `
    <!-- No header here per your doc; header is shown already in AXIOM -->
    <app-timeline-grid
      [showHeader]="false"
      [headers]="store.headersValue"
      [fullHeaderTitles]="store.fullHeaderTitlesValue"
      [dayMeta]="store.dayMetaValue"
      [rows]="store.sourceRowsValue"
      (nav)="onNav($event)"
    />
  `
})
export class SourceSystemsWidget {
  store = inject(Store);
  onNav(action: string) {
    console.log('Source Systems action:', action);
  }
}




//////////////////////

9) src/app/system-health/widgets/mapping-files.widget.ts

import { Component, inject } from '@angular/core';
import { NgFor } from '@angular/common';
import { Store } from '../store';
import { StatusIndicatorComponent } from '../components/status-indicator.component';
import { TooltipCardComponent } from '../components/tooltip-card.component';
import { TooltipData } from '../models';

@Component({
  standalone: true,
  selector: 'app-mapping-files-widget',
  imports: [NgFor, StatusIndicatorComponent, TooltipCardComponent],
  styles: [`
    .wrap { overflow:auto; border:1px solid #e5e7eb; border-radius:8px; }
    .title { font-weight:600; padding:8px 0 6px; }
    table { width:100%; border-collapse:collapse; }
    th, td { padding:10px 12px; border-left:1px solid #f1f5f9; text-align:center; }
    th:first-child, td:first-child { border-left:none; }
  `],
  template: `
    <div class="title">Mapping Files - Monthly Status</div>
    <div class="wrap">
      <table>
        <thead>
          <tr>
            <th *ngFor="let c of store.mappingColsValue">{{ c.label }}</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td *ngFor="let c of store.mappingColsValue" (click)="openTip($event, c.tooltip)">
              <app-status-indicator *ngIf="c.status==='Success'" variant="green"></app-status-indicator>
              <app-status-indicator *ngIf="c.status==='Warning'" variant="amber"></app-status-indicator>
              <app-status-indicator *ngIf="c.status==='Error'"   variant="red"></app-status-indicator>
              <span *ngIf="c.status==='Blank'">-</span>
            </td>
          </tr>
        </tbody>
      </table>
    </div>

    <app-tooltip-card
      [open]="tipOpen"
      [data]="tipData"
      [x]="tipXY.x"
      [y]="tipXY.y"
      (close)="tipOpen=false"
      (action)="onNav($event)"
    />
  `
})
export class MappingFilesWidget {
  store = inject(Store);

  tipOpen = false;
  tipData: TooltipData | null = null;
  tipXY = { x: 0, y: 0 };

  openTip(ev: MouseEvent, data?: TooltipData) {
    if (!data) return;
    const rect = (ev.currentTarget as HTMLElement).getBoundingClientRect();
    this.tipXY = { x: rect.left + rect.width + 8 + window.scrollX, y: rect.top + window.scrollY };
    this.tipData = data;
    this.tipOpen = true;
  }

  onNav(action: string) {
    console.log('Mapping Files action:', action);
  }
}




//////// ---------- Enhancement ------------ /////////////

timeline-grid.component.html


<div class="timeline-grid">
  <!-- Header row -->
  <div class="header-cell file-col">File</div>
  <div 
    class="header-cell day-col" 
    *ngFor="let h of fullHeaderTitles">
    {{h}}
  </div>

  <!-- Rows -->
  <ng-container *ngFor="let row of rows">
    <div class="file-col">{{row.file}}</div>
    <div 
      class="day-col" 
      *ngFor="let status of row.statuses">
      <span class="dot" [ngClass]="status"></span>
    </div>
  </ng-container>
</div>




/////////////////////
timeline-grid.component.scss



.timeline-grid {
  display: grid;
  grid-template-columns: 150px repeat(auto-fill, 48px);
  align-items: center;

  .header-cell {
    font-weight: bold;
    text-align: center;
    padding: 4px;
    border-bottom: 1px solid #ccc;
  }

  .file-col {
    padding: 4px;
    font-weight: 500;
    text-align: left;
    border-right: 1px solid #ddd;
  }

  .day-col {
    width: 48px;
    height: 28px;
    display: flex;
    justify-content: center;
    align-items: center;
  }

  .dot {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    display: inline-block;
  }
  .S { background: green; }   /* Success */
  .W { background: orange; }  /* Warning */
  .E { background: red; }     /* Error */
}




////////////////

store.ts


import { Injectable, signal, computed } from '@angular/core';
import { Row, DayMeta } from './models';
import { buildDayMeta, ingestData } from './data-ingest';
import dummyData from '../../../assets/dummyData.json';

@Injectable({ providedIn: 'root' })
export class Store {
  month = signal<number>(6);  // June
  year = signal<number>(2025);
  dayMeta = signal<DayMeta[]>([]);
  rows = signal<Row[]>([]);

  constructor() {
    this.load();
  }

  headers = computed(() =>
    this.dayMeta().map(d => d.date.split('-')[2])  // e.g. "01"
  );

  fullHeaderTitles = computed(() =>
    this.dayMeta().map(d => d.date) // full YYYY-MM-DD
  );

  load() {
    const meta = buildDayMeta(this.year(), this.month());
    this.dayMeta.set(meta);

    const processed = ingestData(dummyData as any, meta);
    this.rows.set(processed);
  }
}



////////////--------- Enhancement 2 ----------------///////////////

timeline-grid.component.ts

import { Component, EventEmitter, Input, Output } from '@angular/core';
import { NgFor, NgIf, NgSwitch, NgSwitchCase, NgSwitchDefault } from '@angular/common';
import { Cell, DayMeta, TooltipData } from '../models';
import { StatusIndicatorComponent } from './status-indicator.component';
import { TooltipCardComponent } from './tooltip-card.component';

@Component({
  standalone: true,
  selector: 'app-timeline-grid',
  imports: [NgFor, NgIf, NgSwitch, NgSwitchCase, NgSwitchDefault, StatusIndicatorComponent, TooltipCardComponent],
  styles: [`
    /* Container */
    .wrap { overflow:auto; border:1px solid #e5e7eb; border-radius:8px; }

    /* Each "row" (header + data rows) is its own grid */
    .row {
      display: grid;
      align-items: center;

      /* neutralize any legacy styles that may override sizing */
      grid-auto-flow: initial !important;
      grid-auto-columns: initial !important;
    }

    /* Sticky first column (header + data) — must be allowed to shrink to the track width */
    .hdr-stick, .stick {
      position: sticky;
      left: 0;
      z-index: 2;
      background: #fff;
      min-width: 0;      /* allow shrink */
      max-width: 100%;
      box-sizing: border-box;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      padding: 8px 12px;
      border-right: 1px solid #f1f5f9;
      font-weight: 600;
    }

    /* Header */
    .hdr       { color:#475569; border-bottom:1px solid #eef2f7; }
    .hdr-cell  { height: var(--hdr-h, 78px); display:grid; place-items:end center; padding-bottom:6px; border-left:1px solid #f8fafc; }
    .rot       { transform-origin: bottom center; white-space:nowrap; font-size:12px; transform: rotate(var(--hdr-angle, -60deg)); }

    /* Cells */
    .cell      { display:grid; place-items:center; height:34px; border-left:1px solid #f8fafc; }
    .monthly   { background:#f9fafb; border-left:1px solid #eef2f7; border-right:1px solid #eef2f7; }
    .wknd      { background:#f8fafc; }
  `],
  template: `
    <div class="wrap"
         [style.--hdr-h.px]="headerRowHeight"
         [style.--hdr-angle]="headerAngle">

      <!-- HEADER -->
      <div *ngIf="showHeader"
           class="row hdr"
           [style.gridTemplateColumns]="gridTemplate">
        <div class="hdr-stick">{{ headerTitle }}</div>
        <div *ngFor="let h of headers; let i=index"
             class="hdr-cell"
             [title]="fullHeaderTitles?.[i] || h">
          <span class="rot" *ngIf="rotateHeaders; else plain">{{ h }}</span>
          <ng-template #plain>{{ h }}</ng-template>
        </div>
      </div>

      <!-- DATA ROWS -->
      <div *ngFor="let r of rows"
           class="row"
           [style.gridTemplateColumns]="gridTemplate">
        <div class="stick">{{ r.label }}</div>

        <!-- Monthly: one big cell spanning all days -->
        <ng-container *ngIf="isMonthly(r); else daily">
          <div class="cell monthly"
               [style.gridColumn]="gridSpanForMonthly"
               (click)="openTip($event, r.cells[0])">
            <ng-container [ngSwitch]="r.cells[0].kind">
              <app-status-indicator *ngSwitchCase="'Success'" variant="green"></app-status-indicator>
              <app-status-indicator *ngSwitchCase="'Warning'" variant="amber"></app-status-indicator>
              <app-status-indicator *ngSwitchCase="'Error'"   variant="red"></app-status-indicator>
              <app-status-indicator *ngSwitchCase="'NotReceived'" variant="ring"></app-status-indicator>
              <app-status-indicator *ngSwitchCase="'NotGenerated'" variant="red"></app-status-indicator>
              <span *ngSwitchDefault>-</span>
            </ng-container>
          </div>
        </ng-container>

        <!-- Daily cells -->
        <ng-template #daily>
          <div *ngFor="let c of r.cells; let i=index"
               class="cell"
               [class.wknd]="dayMeta[i]?.isWeekend && c.kind==='Blank'"
               (click)="openTip($event, c)">
            <ng-container [ngSwitch]="c.kind">
              <app-status-indicator *ngSwitchCase="'Success'" variant="green"></app-status-indicator>
              <app-status-indicator *ngSwitchCase="'Warning'" variant="amber"></app-status-indicator>
              <app-status-indicator *ngSwitchCase="'Error'"   variant="red"></app-status-indicator>
              <app-status-indicator *ngSwitchCase="'NotReceived'" variant="ring"></app-status-indicator>
              <app-status-indicator *ngSwitchCase="'NotGenerated'" variant="red"></app-status-indicator>
              <!-- Blank → nothing -->
            </ng-container>
          </div>
        </ng-template>
      </div>
    </div>

    <!-- Tooltip -->
    <app-tooltip-card
      [open]="tipOpen"
      [data]="tipData"
      [x]="tipXY.x"
      [y]="tipXY.y"
      (close)="tipOpen=false"
      (action)="nav.emit($event)"
    />
  `
})
export class TimelineGridComponent {
  /** header controls */
  @Input() showHeader = true;
  @Input() headerTitle = '';
  @Input() headers: string[] = [];
  @Input() fullHeaderTitles?: string[];
  @Input() rotateHeaders = true;
  @Input() headerAngle: string = '-60deg';
  @Input() headerRowHeight = 78;

  /** grid data */
  @Input() dayMeta: DayMeta[] = [];
  @Input() rows: Array<{ label: string; cells: (Cell & { colSpan?: number })[] }> = [];

  /** widths */
  @Input() fileColumnWidth = 150;   // px
  @Input() dayColumnWidth  = 48;    // px

  @Output() nav = new EventEmitter<string>();

  tipOpen = false;
  tipData: TooltipData | null = null;
  tipXY = { x: 0, y: 0 };

  /** exactly: "<file px> repeat(<days>, <day px>)" */
  get gridTemplate(): string {
    const days = this.headers?.length ?? 0;
    return `${this.fileColumnWidth}px repeat(${days}, ${this.dayColumnWidth}px)`;
  }

  /** monthly cell spans all day columns (first grid track is the sticky file col) */
  get gridSpanForMonthly(): string {
    return `2 / span ${this.headers.length}`;
  }

  isMonthly(r: { cells: (Cell & { colSpan?: number })[] }) {
    return r.cells.length === 1 && !!r.cells[0].colSpan && r.cells[0].colSpan! > 1;
  }

  openTip(ev: MouseEvent, cell?: Cell) {
    if (!cell?.tooltip) return;
    const rect = (ev.currentTarget as HTMLElement).getBoundingClientRect();
    this.tipXY = { x: rect.left + rect.width + 8 + window.scrollX, y: rect.top + window.scrollY };
    this.tipData = cell.tooltip;
    this.tipOpen = true;
  }
}



/// CSS ///
@Component({
  // ...
  styles: [`
    /* Container */
    .wrap { overflow:auto; border:1px solid #e5e7eb; border-radius:8px; }

    /* Each row (header + data rows) is its own grid; sizing comes from [style.gridTemplateColumns] */
    .row {
      display: grid;
      align-items: center;
      /* hard reset any legacy grid auto rules */
      grid-auto-flow: initial !important;
      grid-auto-columns: initial !important;
    }

    /* First column cells (header and data) – NOT sticky anymore */
    .hdr-stick, .stick {
      /* no sticky, no left, no z-index */
      position: static;
      min-width: 0;          /* allow shrink within 150px track */
      max-width: 100%;
      box-sizing: border-box;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      padding: 8px 12px;
      border-right: 1px solid #f1f5f9;
      font-weight: 600;
      background: transparent;
    }

    /* Header row */
    .hdr       { color:#475569; border-bottom:1px solid #eef2f7; }
    .hdr-cell  {
      height: var(--hdr-h, 78px);
      display: grid;
      place-items: end center;
      padding-bottom: 6px;
      border-left: 1px solid #f8fafc;
    }
    .rot {
      transform-origin: bottom center;
      white-space: nowrap;
      font-size: 12px;
      transform: rotate(var(--hdr-angle, -60deg));
    }

    /* Day cells */
    .cell    { display:grid; place-items:center; height:34px; border-left:1px solid #f8fafc; }
    .monthly { background:#f9fafb; border-left:1px solid #eef2f7; border-right:1px solid #eef2f7; }
    .wknd    { background:#f8fafc; }
  `],
  // ...
})


/////////////----------Enhancement 3------------/////////////////

// Replace your buildDayMeta() with this version:
function buildDayMeta(year: number, month: number): DayMeta[] {
  const daysInMonth = new Date(year, month, 0).getDate(); // month is 1..12
  const today = new Date();
  const toIso = (y: number, m: number, d: number): IsoDate =>
    `${y}-${String(m).padStart(2,'0')}-${String(d).padStart(2,'0')}` as IsoDate;

  const out: DayMeta[] = [];
  for (let day = 1; day <= daysInMonth; day++) {
    const jsDate = new Date(year, month - 1, day); // local time
    const dow = jsDate.getDay();                   // 0=Sun ... 6=Sat
    out.push({
      date: toIso(year, month, day),
      dow,
      isWeekend: dow === 0 || dow === 6,           // Sun OR Sat
      isFuture: jsDate > today,
      isPastOrToday: jsDate <= today,
      hasAnyRecord: false                           // will set below
    });
  }
  return out;
}


/////

load() {
  const meta = buildDayMeta(this.year(), this.month());
  this.dayMeta.set(meta);

  const raw = dummyData as ShRaw[]; // your existing JSON array

  // Mark which dates (across all data) have at least one record
  const datesWithAnyRecord = new Set<string>(raw.map(r => r.sh_report_date));
  for (const d of meta) d.hasAnyRecord = datesWithAnyRecord.has(d.date);

  // Build rows per widget (unchanged)
  this.sourceRows.set(buildGridRows(raw, meta, 'S'));
  this.axiomRows.set(buildGridRows(raw, meta, 'A'));
  this.mappingCols.set(buildMappingColumns(raw));
}
/////

timeline-grid.component.html


<div *ngFor="let c of r.cells; let i=index"
     class="cell"
     [class.wknd]="dayMeta[i]?.isWeekend && !dayMeta[i]?.hasAnyRecord && c.kind==='Blank'"
     (click)="openTip($event, c)">
  <!-- rest unchanged -->
</div>

